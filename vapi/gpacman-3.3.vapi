/* gpacman-3.3.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "Pacman", lower_case_cprefix = "pacman_")]
namespace Pacman {
	[Compact]
	[CCode (cheader_filename = "pacman.h")]
	public class Conflict {
		public static Pacman.List<Pacman.Conflict> check_packages (Pacman.List<Pacman.Package> packages);
		public unowned string get_first_package ();
		public unowned string get_second_package ();
	}
	[Compact]
	[CCode (cheader_filename = "pacman.h")]
	public class Database {
		public void add_server (string url);
		public unowned Pacman.Group find_group (string name);
		public unowned Pacman.Package find_package (string name);
		public unowned Pacman.List<Pacman.Group> get_groups ();
		public unowned string get_name ();
		public unowned Pacman.List<Pacman.Package> get_packages ();
		public unowned string get_server ();
		public Pacman.List<Pacman.Package> search (Pacman.List<string> needles);
	}
	[Compact]
	[CCode (cheader_filename = "pacman.h")]
	public class Delta {
		public unowned string get_from_filename ();
		public unowned string get_patch_filename ();
		public unowned string get_patch_md5sum ();
		public int64 get_patch_size ();
		public unowned string get_to_filename ();
	}
	[Compact]
	[CCode (cheader_filename = "pacman.h")]
	public class Dependency {
		public Pacman.DependencyCompare get_compare_operation ();
		public unowned string get_name ();
		public unowned string? get_version ();
		public bool satisfied_by (Pacman.Package package);
		public string to_string ();
	}
	[Compact]
	[CCode (cheader_filename = "pacman.h")]
	public class FileConflict {
		public unowned string get_file ();
		public unowned string get_package ();
		public unowned string? get_second_package ();
	}
	[Compact]
	[CCode (cheader_filename = "pacman.h")]
	public class Group {
		public unowned string get_name ();
		public unowned Pacman.List<Pacman.Package> get_packages ();
	}
	[CCode (cheader_filename = "pacman.h")]
	public class Install : Pacman.Transaction {
	}
	[Compact]
	[CCode (copy_function = "pacman_list_copy", cheader_filename = "pacman.h")]
	public class List<G> {
		public List ();
		[ReturnsModifiedPointer]
		public void add (owned G item);
		[ReturnsModifiedPointer]
		public void add_sorted (owned G item, GLib.CompareFunc func);
		[ReturnsModifiedPointer]
		public void concat (owned Pacman.List<G> second);
		public Pacman.List<weak G> copy ();
		public Pacman.List<weak G> diff (Pacman.List<G> rhs, GLib.CompareFunc func);
		public unowned G find (G needle, GLib.CompareFunc func);
		public unowned G find_direct (G needle);
		public void free_contents (GLib.DestroyNotify func);
		public unowned G @get ();
		public uint length ();
		public unowned Pacman.List<G> next ();
		public unowned Pacman.List<G> nth (uint n);
		[ReturnsModifiedPointer]
		public void remove (G needle, GLib.CompareFunc func, out G removed);
		[ReturnsModifiedPointer]
		public void remove_direct (G needle, out G removed);
		public Pacman.List<weak G> remove_duplicates ();
		public Pacman.List<weak G> reverse ();
		public void @set (G item);
		[ReturnsModifiedPointer]
		public void sort (GLib.CompareFunc func);
	}
	[CCode (cheader_filename = "pacman.h")]
	public class Manager : GLib.Object {
		public void add_cache_path (string path);
		public void add_hold_package (string package);
		public void add_ignore_group (string group);
		public void add_ignore_package (string package);
		public void add_no_extract (string filename);
		public void add_no_upgrade (string filename);
		public void add_sync_first (string package);
		public bool configure (string? filename) throws GLib.Error;
		public Pacman.List<Pacman.MissingDependency> find_missing_dependencies (Pacman.List<Pacman.Package> remove, Pacman.List<Pacman.Package> install);
		public unowned Pacman.Database? find_sync_database (string name);
		public static Pacman.Manager @get () throws GLib.Error;
		public unowned Pacman.List<string> get_cache_paths ();
		public unowned string get_clean_method ();
		public unowned string get_database_path ();
		public unowned Pacman.List<string> get_hold_packages ();
		public bool get_i_love_candy ();
		public unowned Pacman.List<string> get_ignore_groups ();
		public unowned Pacman.List<string> get_ignore_packages ();
		public unowned Pacman.Database? get_local_database ();
		public unowned string get_log_file ();
		public unowned Pacman.List<string> get_no_extracts ();
		public bool get_no_passive_ftp ();
		public unowned Pacman.List<string> get_no_upgrades ();
		public unowned string get_root_path ();
		public bool get_show_size ();
		public unowned Pacman.List<Pacman.Database> get_sync_databases ();
		public unowned Pacman.List<string> get_sync_firsts ();
		public bool get_total_download ();
		public unowned Pacman.Transaction? get_transaction ();
		public bool get_use_delta ();
		public bool get_use_syslog ();
		public unowned string get_version ();
		public Pacman.Transaction install (uint32 flags) throws GLib.Error;
		public unowned Pacman.Database register_local_database () throws GLib.Error;
		public unowned Pacman.Database register_sync_database (string name) throws GLib.Error;
		public Pacman.Transaction remove (uint32 flags) throws GLib.Error;
		public bool remove_cache_path (string path);
		public bool remove_hold_package (string package);
		public bool remove_ignore_group (string group);
		public bool remove_ignore_package (string package);
		public bool remove_no_extract (string filename);
		public bool remove_no_upgrade (string filename);
		public bool remove_sync_first (string package);
		public void set_cache_paths (Pacman.List<string> paths);
		public void set_clean_method (string method);
		public bool set_database_path (string path) throws GLib.Error;
		public void set_hold_packages (Pacman.List<string> packages);
		public void set_i_love_candy (bool value);
		public void set_ignore_groups (Pacman.List<string> groups);
		public void set_ignore_packages (Pacman.List<string> packages);
		public void set_log_file (string filename);
		public void set_no_extracts (Pacman.List<string> filenames);
		public void set_no_passive_ftp (bool value);
		public void set_no_upgrades (Pacman.List<string> filenames);
		public bool set_root_path (string path) throws GLib.Error;
		public void set_show_size (bool value);
		public void set_sync_firsts (Pacman.List<string> packages);
		public void set_total_download (bool value);
		public void set_transfer_closure (GLib.Closure closure);
		public void set_transfer_command (string? command);
		public void set_transfer_handler (Pacman.TransferFunc func, GLib.ClosureNotify destroy_data);
		public void set_use_delta (bool value);
		public void set_use_syslog (bool value);
		public Pacman.Transaction sync (uint32 flags) throws GLib.Error;
		public Pacman.List<string> test_dependencies (Pacman.List<string> dependencies);
		public bool unregister_all_databases () throws GLib.Error;
		public bool unregister_database (Pacman.Database database) throws GLib.Error;
		public Pacman.Transaction update (uint32 flags) throws GLib.Error;
		public Pacman.Transaction transaction { get; }
		public string version { get; }
	}
	[Compact]
	[CCode (cheader_filename = "pacman.h")]
	public class MissingDependency {
		public unowned string? get_causing_package ();
		public unowned Pacman.Dependency get_dependency ();
		public unowned string get_package ();
	}
	[Compact]
	[CCode (cheader_filename = "pacman.h")]
	public class Package {
		public bool check_md5sum () throws GLib.Error;
		public static int compare_version (string a, string b);
		public unowned Pacman.Package? find_new_version (Pacman.List<Pacman.Database> databases);
		public Pacman.List<string> find_required_by ();
		[CCode (has_construct_function = false)]
		public Package.from_file (string filename, bool full) throws GLib.Error;
		public static string generate_md5sum (string filename) throws GLib.Error;
		public unowned string get_arch ();
		public unowned Pacman.List<string> get_backup ();
		public ulong get_build_date ();
		public unowned Pacman.List<string> get_conflicts ();
		public unowned Pacman.Database? get_database ();
		public unowned Pacman.List<Pacman.Delta> get_deltas ();
		public unowned Pacman.List<Pacman.Dependency> get_dependencies ();
		public unowned string get_description ();
		public int64 get_download_size ();
		public unowned string? get_filename ();
		public unowned Pacman.List<string> get_files ();
		public unowned Pacman.List<string> get_groups ();
		public ulong get_install_date ();
		public int64 get_installed_size ();
		public unowned Pacman.List<string> get_licenses ();
		public unowned string? get_md5sum ();
		public unowned string get_name ();
		public unowned Pacman.List<string> get_optional_dependencies ();
		public unowned string? get_packager ();
		public unowned Pacman.List<string> get_provides ();
		public unowned Pacman.List<Pacman.Package> get_removes ();
		public unowned Pacman.List<string> get_replaces ();
		public int64 get_size ();
		public unowned string get_url ();
		public unowned string get_version ();
		public bool has_force ();
		public bool has_install_scriptlet ();
		public static string make_list (Pacman.List<Pacman.Package> packages);
		public string? read_changelog ();
		public bool was_explicitly_installed ();
	}
	[CCode (cheader_filename = "pacman.h")]
	public class Remove : Pacman.Transaction {
	}
	[CCode (cheader_filename = "pacman.h")]
	public class Sync : Pacman.Transaction {
	}
	[CCode (cheader_filename = "pacman.h")]
	public class Transaction : GLib.Object {
		public bool cancel () throws GLib.Error;
		public virtual bool commit () throws GLib.Error;
		public unowned Pacman.List<Pacman.Conflict> get_conflicts ();
		public unowned Pacman.List<Pacman.FileConflict> get_file_conflicts ();
		public uint32 get_flags ();
		public unowned Pacman.List<string> get_invalid_files ();
		public unowned Pacman.List<Pacman.Package> get_marked_packages ();
		public unowned Pacman.List<Pacman.MissingDependency> get_missing_dependencies ();
		public unowned Pacman.List<Pacman.Package> get_packages ();
		public virtual bool prepare (Pacman.List<string> targets) throws GLib.Error;
		public virtual signal void download (string p0, uint p1, uint p2);
		public virtual signal void progress (Pacman.TransactionProgress p0, string p1, uint p2, uint p3, uint p4);
		public virtual signal bool question (Pacman.TransactionQuestion p0, string p1);
		public virtual signal void status (Pacman.TransactionStatus p0, string p1);
	}
	[CCode (cheader_filename = "pacman.h")]
	public class Update : Pacman.Transaction {
		public unowned Pacman.List<Pacman.Database> get_databases ();
	}
	[CCode (cprefix = "PACMAN_DEPENDENCY_COMPARE_", cheader_filename = "pacman.h")]
	public enum DependencyCompare {
		ANY,
		EQUAL,
		NEWER_OR_EQUAL,
		OLDER_OR_EQUAL,
		NEWER,
		OLDER
	}
	[CCode (cprefix = "PACMAN_TRANSACTION_FLAGS_", cheader_filename = "pacman.h")]
	[Flags]
	public enum TransactionFlags {
		NONE,
		IGNORE_DEPENDENCIES,
		IGNORE_FILE_CONFLICTS,
		REMOVE_BACKUPS,
		REMOVE_CASCADE,
		REMOVE_RECURSIVE,
		REMOVE_KEEP_FILES,
		INSTALL_IMPLICIT,
		SYNC_DOWNLOAD_ONLY,
		INSTALL_IGNORE_SCRIPTLET,
		IGNORE_DEPENDENCY_CONFLICTS,
		SYNC_ALLOW_DOWNGRADE,
		SYNC_OUTDATED_ONLY,
		INSTALL_EXPLICIT,
		REMOVE_UNNEEDED_ONLY,
		REMOVE_RECURSIVE_EXPLICIT,
		IGNORE_DATABASE_LOCK
	}
	[CCode (cprefix = "PACMAN_TRANSACTION_PROGRESS_", cheader_filename = "pacman.h")]
	public enum TransactionProgress {
		INSTALL,
		UPGRADE,
		REMOVE,
		FILE_CONFLICT_CHECK
	}
	[CCode (cprefix = "PACMAN_TRANSACTION_QUESTION_", cheader_filename = "pacman.h")]
	public enum TransactionQuestion {
		INSTALL_IGNORE_PACKAGE,
		REPLACE_PACKAGE,
		REMOVE_CONFLICTING_PACKAGE,
		SKIP_UNRESOLVABLE_PACKAGES,
		INSTALL_OLDER_PACKAGE,
		DELETE_CORRUPTED_PACKAGE,
		REMOVE_HOLD_PACKAGES,
		SYNC_FIRST
	}
	[CCode (cprefix = "PACMAN_TRANSACTION_STATUS_", cheader_filename = "pacman.h")]
	public enum TransactionStatus {
		DEPENDENCY_CHECK_START,
		DEPENDENCY_CHECK_END,
		FILE_CONFLICT_CHECK_START,
		FILE_CONFLICT_CHECK_END,
		DEPENDENCY_RESOLVE_START,
		DEPENDENCY_RESOLVE_END,
		CONFLICT_CHECK_START,
		CONFLICT_CHECK_END,
		INSTALL_START,
		INSTALL_END,
		REMOVE_START,
		REMOVE_END,
		UPGRADE_START,
		UPGRADE_END,
		PACKAGE_INTEGRITY_CHECK_START,
		PACKAGE_INTEGRITY_CHECK_END,
		DELTA_INTEGRITY_CHECK_START,
		DELTA_INTEGRITY_CHECK_END,
		DELTA_PATCHING_START,
		DELTA_PATCHING_END,
		DELTA_PATCH_START,
		DELTA_PATCH_END,
		DOWNLOAD_START,
		DOWNLOAD_FROM,
		DOWNLOAD_END
	}
	[CCode (cprefix = "PACMAN_ERROR_", cheader_filename = "pacman.h")]
	public errordomain Error {
		MEMORY,
		SYSTEM,
		NOT_PERMITTED,
		FILE_NOT_FOUND,
		DIRECTORY_NOT_FOUND,
		INVALID_ARGS,
		NOT_INITIALIZED,
		ALREADY_INITIALIZED,
		ALREADY_RUNNING,
		DATABASE_OPEN_FAILED,
		DATABASE_CREATE_FAILED,
		DATABASE_NOT_INITIALIZED,
		DATABASE_ALREADY_INITIALIZED,
		DATABASE_NOT_FOUND,
		DATABASE_UPDATE_FAILED,
		DATABASE_REMOVE_FAILED,
		SERVER_INVALID_URL,
		SERVER_NONE_AVAILABLE,
		TRANSACTION_ALREADY_INITIALIZED,
		TRANSACTION_NOT_INITIALIZED,
		TRANSACTION_DUPLICATE_TARGET,
		TRANSACTION_NOT_READY,
		TRANSACTION_NOT_PREPARED,
		TRANSACTION_ABORTED,
		TRANSACTION_INVALID_OPERATION,
		TRANSACTION_NOT_LOCKED,
		PACKAGE_NOT_FOUND,
		PACKAGE_IGNORED,
		PACKAGE_INVALID,
		PACKAGE_OPEN_FAILED,
		PACKAGE_REMOVE_FAILED,
		PACKAGE_UNKNOWN_FILENAME,
		PACKAGE_DATABASE_NOT_FOUND,
		DELTA_INVALID,
		DELTA_PATCH_FAILED,
		DEPENDENCY_UNSATISFIED,
		CONFLICT,
		FILE_CONFLICT,
		DOWNLOAD_FAILED,
		REGEX_INVALID,
		LIBARCHIVE,
		LIBFETCH,
		DOWNLOAD_HANDLER,
		CONFIG_INVALID,
		PACKAGE_HELD,
	}
	[CCode (cheader_filename = "pacman.h")]
	public delegate bool TransferFunc (Pacman.Manager manager, string url, string filename, ulong mtime);
	[CCode (cheader_filename = "pacman.h")]
	public static GLib.Quark error_quark ();
}
