diff -Nru a/backends/Makefile.am b/backends/Makefile.am
--- a/backends/Makefile.am	2010-03-09 06:28:15.000000000 +1300
+++ b/backends/Makefile.am	2010-04-06 02:44:38.696880374 +1200
@@ -32,6 +32,10 @@
 SUBDIRS += opkg
 endif
 
+if BACKEND_TYPE_PACMAN
+SUBDIRS += pacman
+endif
+
 if BACKEND_TYPE_RAZOR
 SUBDIRS += razor
 endif
diff -Nru a/backends/pacman/backend-depends.c b/backends/pacman/backend-depends.c
--- a/backends/pacman/backend-depends.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-depends.c	2010-04-08 12:11:18.693018817 +1200
@@ -0,0 +1,298 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-packages.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+#include "backend-depends.h"
+
+static PacmanPackage *
+pacman_list_find_provider (const PacmanList *packages, PacmanDependency *depend)
+{
+	const PacmanList *list;
+
+	g_return_val_if_fail (depend != NULL, NULL);
+
+	/* find a package that provides depend */
+	for (list = packages; list != NULL; list = pacman_list_next (list)) {
+		PacmanPackage *provider = (PacmanPackage *) pacman_list_get (list);
+
+		if (pacman_dependency_satisfied_by (depend, provider)) {
+			return provider;
+		}
+	}
+
+	return NULL;
+}
+
+static PacmanPackage *
+pacman_sync_databases_find_provider (PacmanDependency *depend)
+{
+	const PacmanList *databases;
+
+	g_return_val_if_fail (pacman != NULL, NULL);
+	g_return_val_if_fail (depend != NULL, NULL);
+
+	/* find the default package that provides depend */
+	for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+		PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+		PacmanPackage *provider = pacman_database_find_package (database, pacman_dependency_get_name (depend));
+
+		if (provider != NULL && pacman_dependency_satisfied_by (depend, provider)) {
+			return provider;
+		}
+	}
+
+	/* find any package that provides depend */
+	for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+		PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+		PacmanPackage *provider = pacman_list_find_provider (pacman_database_get_packages (database), depend);
+
+		if (provider != NULL) {
+			return provider;
+		}
+	}
+
+	return NULL;
+}
+
+static gboolean
+backend_get_depends_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list, *packages = NULL;
+
+	PkBitfield filters;
+	gchar **package_ids;
+	gboolean recursive;
+
+	gboolean search_installed;
+	gboolean search_not_installed;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	filters = pk_backend_get_uint (backend, "filters");
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	recursive = pk_backend_get_bool (backend, "recursive");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	search_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_INSTALLED);
+	search_not_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_NOT_INSTALLED);
+
+	/* construct an initial package list */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+
+		if (backend_cancelled (backend)) {
+			break;
+		} else if (package == NULL) {
+			pacman_list_free (packages);
+			backend_finished (backend);
+			return FALSE;
+		}
+
+		packages = pacman_list_add (packages, package);
+	}
+
+	/* package list might be modified along the way but that is ok */
+	for (list = packages; list != NULL; list = pacman_list_next (list)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (list);
+		const PacmanList *depends;
+
+		if (backend_cancelled (backend)) {
+			break;
+		}
+
+		for (depends = pacman_package_get_dependencies (package); depends != NULL; depends = pacman_list_next (depends)) {
+			PacmanDependency *depend = (PacmanDependency *) pacman_list_get (depends);
+			PacmanPackage *provider = pacman_list_find_provider (packages, depend);
+
+			if (backend_cancelled (backend)) {
+				break;
+			} else if (provider != NULL) {
+				continue;
+			}
+
+			/* look for installed dependencies */
+			provider = pacman_list_find_provider (pacman_database_get_packages (local_database), depend);
+			if (provider != NULL) {
+				/* don't emit when not needed... */
+				if (!search_not_installed) {
+					backend_package (backend, provider, PK_INFO_ENUM_INSTALLED);
+					/* ... and assume installed packages also have installed dependencies */
+					if (recursive) {
+						packages = pacman_list_add (packages, provider);
+					}
+				}
+				continue;
+			}
+
+			/* look for non-installed dependencies */
+			provider = pacman_sync_databases_find_provider (depend);
+			if (provider != NULL) {
+				/* don't emit when not needed... */
+				if (!search_installed) {
+					backend_package (backend, provider, PK_INFO_ENUM_AVAILABLE);
+				}
+				/* ... but keep looking for installed dependencies */
+				if (recursive) {
+					packages = pacman_list_add (packages, provider);
+				}
+			} else {
+				gchar *depend_id = pacman_dependency_to_string (depend);
+				pk_backend_error_code (backend, PK_ERROR_ENUM_DEP_RESOLUTION_FAILED, "Could not resolve dependency %s", depend_id);
+				g_free (depend_id);
+
+				pacman_list_free (packages);
+				backend_finished (backend);
+				return FALSE;
+			}
+		}
+	}
+
+	pacman_list_free (packages);
+	backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_depends:
+ **/
+void
+backend_get_depends (PkBackend *backend, PkBitfield filters, gchar **package_ids, gboolean recursive)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_get_depends_thread);
+}
+
+static PacmanPackage *
+pacman_list_find_package (const PacmanList *packages, const gchar *name)
+{
+	const PacmanList *list;
+
+	g_return_val_if_fail (name != NULL, NULL);
+
+	/* find a package called name */
+	for (list = packages; list != NULL; list = pacman_list_next (list)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (list);
+
+		if (g_strcmp0 (name, pacman_package_get_name (package)) == 0) {
+			return package;
+		}
+	}
+
+	return NULL;
+}
+
+static gboolean
+backend_get_requires_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list, *packages = NULL;
+
+	gchar **package_ids;
+	gboolean recursive;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	recursive = pk_backend_get_bool (backend, "recursive");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* construct an initial package list */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+
+		if (backend_cancelled (backend)) {
+			break;
+		} else if (package == NULL) {
+			pacman_list_free (packages);
+			backend_finished (backend);
+			return FALSE;
+		}
+
+		packages = pacman_list_add (packages, package);
+	}
+
+	/* package list might be modified along the way but that is ok */
+	for (list = packages; list != NULL; list = pacman_list_next (list)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (list);
+		PacmanList *requires, *required_by = pacman_package_find_required_by (package);
+
+		if (backend_cancelled (backend)) {
+			break;
+		}
+
+		for (requires = required_by; requires != NULL; requires = pacman_list_next (requires)) {
+			const gchar *name = (const gchar *) pacman_list_get (requires);
+			PacmanPackage *requirer = pacman_list_find_package (packages, name);
+
+			if (backend_cancelled (backend)) {
+				break;
+			} else if (requirer != NULL) {
+				continue;
+			}
+
+			/* look for installed requirers */
+			requirer = pacman_database_find_package (local_database, name);
+			if (requirer == NULL) {
+				pk_backend_error_code (backend, PK_ERROR_ENUM_PACKAGE_NOT_FOUND, "Could not find package %s", name);
+
+				pacman_list_free_full (required_by, g_free);
+				pacman_list_free (packages);
+				backend_finished (backend);
+				return FALSE;
+			}
+
+			backend_package (backend, requirer, PK_INFO_ENUM_INSTALLED);
+			if (recursive) {
+				packages = pacman_list_add (packages, requirer);
+			}
+		}
+
+		pacman_list_free_full (required_by, g_free);
+	}
+
+	pacman_list_free (packages);
+	backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_requires:
+ **/
+void
+backend_get_requires (PkBackend *backend, PkBitfield filters, gchar **package_ids, gboolean recursive)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_get_requires_thread);
+}
diff -Nru a/backends/pacman/backend-depends.h b/backends/pacman/backend-depends.h
--- a/backends/pacman/backend-depends.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-depends.h	2010-04-06 02:44:38.700216833 +1200
@@ -0,0 +1,33 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_get_depends	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**package_ids,
+				 gboolean	 recursive);
+void	 backend_get_requires	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**package_ids,
+				 gboolean	 recursive);
diff -Nru a/backends/pacman/backend-error.c b/backends/pacman/backend-error.c
--- a/backends/pacman/backend-error.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-error.c	2010-04-06 02:44:38.700216833 +1200
@@ -0,0 +1,185 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-error.h"
+
+void
+backend_error (PkBackend *backend, GError *error)
+{
+	PkErrorEnum code = PK_ERROR_ENUM_INTERNAL_ERROR;
+
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (error != NULL);
+
+	/* convert error codes */
+	if (error->domain == PACMAN_ERROR) {
+		switch (error->code) {
+			case PACMAN_ERROR_MEMORY:
+				code = PK_ERROR_ENUM_OOM;
+				break;
+
+			case PACMAN_ERROR_SYSTEM:
+			case PACMAN_ERROR_INVALID_ARGS:
+			case PACMAN_ERROR_NOT_INITIALIZED:
+			case PACMAN_ERROR_DATABASE_NOT_INITIALIZED:
+			case PACMAN_ERROR_SERVER_INVALID_URL:
+			case PACMAN_ERROR_REGEX_INVALID:
+			case PACMAN_ERROR_LIBARCHIVE:
+			case PACMAN_ERROR_LIBFETCH:
+			case PACMAN_ERROR_DOWNLOAD_HANDLER:
+				code = PK_ERROR_ENUM_INTERNAL_ERROR;
+				break;
+
+			case PACMAN_ERROR_NOT_PERMITTED:
+				code = PK_ERROR_ENUM_NOT_AUTHORIZED;
+				break;
+
+			case PACMAN_ERROR_FILE_NOT_FOUND:
+			case PACMAN_ERROR_DIRECTORY_NOT_FOUND:
+				code = PK_ERROR_ENUM_FILE_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_ALREADY_INITIALIZED:
+			case PACMAN_ERROR_DATABASE_ALREADY_INITIALIZED:
+				code = PK_ERROR_ENUM_FAILED_INITIALIZATION;
+				break;
+
+			case PACMAN_ERROR_ALREADY_RUNNING:
+				code = PK_ERROR_ENUM_CANNOT_GET_LOCK;
+				break;
+
+			case PACMAN_ERROR_DATABASE_OPEN_FAILED:
+				code = PK_ERROR_ENUM_REPO_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_DATABASE_CREATE_FAILED:
+				code = PK_ERROR_ENUM_CANNOT_WRITE_REPO_CONFIG;
+				break;
+
+			case PACMAN_ERROR_DATABASE_NOT_FOUND:
+				code = PK_ERROR_ENUM_REPO_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_DATABASE_UPDATE_FAILED:
+				code = PK_ERROR_ENUM_REPO_NOT_AVAILABLE;
+				break;
+
+			case PACMAN_ERROR_DATABASE_REMOVE_FAILED:
+				code = PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR;
+				break;
+
+			case PACMAN_ERROR_SERVER_NONE_AVAILABLE:
+				code = PK_ERROR_ENUM_NO_MORE_MIRRORS_TO_TRY;
+				break;
+
+			case PACMAN_ERROR_TRANSACTION_ALREADY_INITIALIZED:
+			case PACMAN_ERROR_TRANSACTION_NOT_INITIALIZED:
+			case PACMAN_ERROR_TRANSACTION_DUPLICATE_TARGET:
+			case PACMAN_ERROR_TRANSACTION_NOT_READY:
+			case PACMAN_ERROR_TRANSACTION_NOT_PREPARED:
+			case PACMAN_ERROR_TRANSACTION_INVALID_OPERATION:
+			case PACMAN_ERROR_TRANSACTION_NOT_LOCKED:
+				code = PK_ERROR_ENUM_TRANSACTION_ERROR;
+				break;
+
+			case PACMAN_ERROR_TRANSACTION_ABORTED:
+				code = PK_ERROR_ENUM_TRANSACTION_CANCELLED;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_NOT_FOUND:
+				code = PK_ERROR_ENUM_PACKAGE_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_IGNORED:
+				code = PK_ERROR_ENUM_PACKAGE_INSTALL_BLOCKED;
+				break;
+
+			case PACMAN_ERROR_DELTA_INVALID:
+			case PACMAN_ERROR_PACKAGE_INVALID:
+				code = PK_ERROR_ENUM_INVALID_PACKAGE_FILE;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_OPEN_FAILED:
+				code = PK_ERROR_ENUM_PACKAGE_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_REMOVE_FAILED:
+				code = PK_ERROR_ENUM_PACKAGE_FAILED_TO_REMOVE;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_UNKNOWN_FILENAME:
+			case PACMAN_ERROR_PACKAGE_DATABASE_NOT_FOUND:
+				code = PK_ERROR_ENUM_PACKAGE_FAILED_TO_CONFIGURE;
+				break;
+
+			case PACMAN_ERROR_DELTA_PATCH_FAILED:
+				code = PK_ERROR_ENUM_PACKAGE_FAILED_TO_BUILD;
+				break;
+
+			case PACMAN_ERROR_DEPENDENCY_UNSATISFIED:
+				code = PK_ERROR_ENUM_DEP_RESOLUTION_FAILED;
+				break;
+
+			case PACMAN_ERROR_CONFLICT:
+				code = PK_ERROR_ENUM_PACKAGE_CONFLICTS;
+				break;
+
+			case PACMAN_ERROR_FILE_CONFLICT:
+				code = PK_ERROR_ENUM_FILE_CONFLICTS;
+				break;
+
+			case PACMAN_ERROR_DOWNLOAD_FAILED:
+				code = PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED;
+				break;
+
+			case PACMAN_ERROR_CONFIG_INVALID:
+				code = PK_ERROR_ENUM_FAILED_CONFIG_PARSING;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_HELD:
+				code = PK_ERROR_ENUM_CANNOT_REMOVE_SYSTEM_PACKAGE;
+				break;
+		}
+	}
+
+	pk_backend_error_code (backend, code, "%s", error->message);
+	g_error_free (error);
+}
+
+void
+backend_message (PkBackend *backend, const gchar *message)
+{
+	guint iterator;
+	gchar **messages = g_strsplit_set (message, "\r\n", 0);
+
+	/* display multi-line messages in a nice format */
+	for (iterator = 0; messages[iterator] != NULL; ++iterator) {
+		g_strstrip (messages[iterator]);
+		if (*messages[iterator] != '\0') {
+			pk_backend_message (backend, PK_MESSAGE_ENUM_UNKNOWN, "%s", messages[iterator]);
+		}
+	}
+
+	g_strfreev (messages);
+}
diff -Nru a/backends/pacman/backend-error.h b/backends/pacman/backend-error.h
--- a/backends/pacman/backend-error.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-error.h	2010-04-06 02:44:38.700216833 +1200
@@ -0,0 +1,29 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_error		(PkBackend	*backend,
+				 GError		*error);
+void	 backend_message	(PkBackend	*backend,
+				 const gchar	*message);
diff -Nru a/backends/pacman/backend-groups.c b/backends/pacman/backend-groups.c
--- a/backends/pacman/backend-groups.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-groups.c	2010-04-07 17:46:57.726973627 +1200
@@ -0,0 +1,150 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <string.h>
+#include <gio/gio.h>
+#include "backend-error.h"
+#include "backend-groups.h"
+
+static GHashTable *group_map = NULL;
+static PkBitfield groups = 0;
+
+static GHashTable *
+group_map_new (GError **error)
+{
+	GHashTable *map;
+	GFile *file;
+
+	GFileInputStream *file_stream;
+	GDataInputStream *data_stream;
+
+	gchar *key, *value;
+	GError *e = NULL;
+
+	egg_debug ("pacman: reading groups from %s", PACMAN_GROUP_LIST);
+	file = g_file_new_for_path (PACMAN_GROUP_LIST);
+	file_stream = g_file_read (file, NULL, &e);
+
+	if (file_stream == NULL) {
+		g_object_unref (file);
+		g_propagate_error (error, e);
+		return NULL;
+	}
+
+	map = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+	data_stream = g_data_input_stream_new (G_INPUT_STREAM (file_stream));
+
+	/* read groups line by line, ignoring comments */
+	while ((value = g_data_input_stream_read_line (data_stream, NULL, NULL, &e)) != NULL) {
+		PkGroupEnum group;
+
+		g_strstrip (value);
+		if (*value == '\0' || *value == '#') {
+			g_free (value);
+			continue;
+		}
+
+		/* line format: alpm-group (space|tab)+ packagekit-group */
+		key = strsep (&value, " 	");
+		g_strchomp (key);
+
+		if (value == NULL) {
+			/* safe to cast as it is never freed or modified */
+			value = (gchar *) "other";
+			group = PK_GROUP_ENUM_OTHER;
+		} else {
+			g_strchug (value);
+			group = pk_group_enum_from_string (value);
+		}
+
+		if (group != PK_GROUP_ENUM_UNKNOWN) {
+			/* use replace because key and value are allocated together */
+			g_hash_table_replace (map, key, value);
+			pk_bitfield_add (groups, group);
+		}
+	}
+
+	g_object_unref (data_stream);
+	g_object_unref (file_stream);
+	g_object_unref (file);
+
+	if (e != NULL) {
+		g_hash_table_unref (map);
+		g_propagate_error (error, e);
+		return NULL;
+	} else {
+		return map;
+	}
+}
+
+gboolean
+backend_initialize_groups (PkBackend *backend, GError **error)
+{
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	group_map = group_map_new (error);
+	if (group_map == NULL) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+void
+backend_destroy_groups (PkBackend *backend)
+{
+	g_return_if_fail (backend != NULL);
+
+	if (group_map != NULL) {
+		g_hash_table_unref (group_map);
+	}
+}
+
+const gchar *
+pacman_package_get_group (PacmanPackage *package)
+{
+	const PacmanList *list;
+
+	g_return_val_if_fail (group_map != NULL, NULL);
+	g_return_val_if_fail (package != NULL, NULL);
+
+	/* use the first group that we recognise */
+	for (list = pacman_package_get_groups (package); list != NULL; list = pacman_list_next (list)) {
+		gpointer value = g_hash_table_lookup (group_map, pacman_list_get (list));
+		if (value != NULL) {
+			return (const gchar *) value;
+		}
+	}
+
+	return "other";
+}
+
+/**
+ * backend_get_groups:
+ **/
+PkBitfield backend_get_groups (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, 0);
+
+	return groups;
+}
diff -Nru a/backends/pacman/backend-groups.h b/backends/pacman/backend-groups.h
--- a/backends/pacman/backend-groups.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-groups.h	2010-04-07 17:42:38.533667693 +1200
@@ -0,0 +1,32 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <pk-backend.h>
+
+gboolean	 backend_initialize_groups	(PkBackend	*backend,
+						 GError		**error);
+void		 backend_destroy_groups		(PkBackend	*backend);
+
+const gchar	*pacman_package_get_group	(PacmanPackage	*package);
+PkBitfield	 backend_get_groups		(PkBackend	*backend);
diff -Nru a/backends/pacman/backend-install.c b/backends/pacman/backend-install.c
--- a/backends/pacman/backend-install.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-install.c	2010-04-08 12:14:09.925496215 +1200
@@ -0,0 +1,236 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-error.h"
+#include "backend-pacman.h"
+#include "backend-packages.h"
+#include "backend-transaction.h"
+#include "backend-install.h"
+
+static gboolean
+backend_download_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+	PacmanList *cache_paths;
+
+	gchar **package_ids;
+	const gchar *directory;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_IGNORE_DEPENDENCIES | PACMAN_TRANSACTION_FLAGS_IGNORE_DEPENDENCY_CONFLICTS | PACMAN_TRANSACTION_FLAGS_SYNC_DOWNLOAD_ONLY;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	directory = pk_backend_get_string (backend, "directory");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+	g_return_val_if_fail (directory != NULL, FALSE);
+
+	/* download files to a PackageKit directory */
+	cache_paths = pacman_list_strdup (pacman_manager_get_cache_paths (pacman));
+	pacman_manager_set_cache_paths (pacman, NULL);
+	pacman_manager_add_cache_path (pacman, directory);
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup_printf ("%s/%s", package_id_data[PK_PACKAGE_ID_DATA], package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_SYNC, flags, list);
+		pacman_list_free_full (list, g_free);
+	}
+
+	pacman_manager_set_cache_paths (pacman, cache_paths);
+	pacman_list_free_full (cache_paths, g_free);
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_download_packages:
+ **/
+void
+backend_download_packages (PkBackend *backend, gchar **package_ids, const gchar *directory)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+	g_return_if_fail (directory != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_download_packages_thread);
+}
+
+static gboolean
+backend_install_files_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	/* FS#5331: use only_trusted */
+	gchar **full_paths;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	full_paths = pk_backend_get_strv (backend, "full_paths");
+
+	g_return_val_if_fail (full_paths != NULL, FALSE);
+
+	/* collect targets for the transaction */
+	for (iterator = 0; full_paths[iterator] != NULL; ++iterator) {
+		list = pacman_list_add (list, full_paths[iterator]);
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_INSTALL, flags, list);
+		pacman_list_free (list);
+	}
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_install_files:
+ **/
+void
+backend_install_files (PkBackend *backend, gboolean only_trusted, gchar	**full_paths)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (full_paths != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_install_files_thread);
+}
+
+static gboolean
+backend_install_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	/* FS#5331: use only_trusted */
+	gchar **package_ids;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup_printf ("%s/%s", package_id_data[PK_PACKAGE_ID_DATA], package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_SYNC, flags, list);
+		pacman_list_free_full (list, g_free);
+	}
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_install_packages:
+ **/
+void
+backend_install_packages (PkBackend *backend, gboolean only_trusted, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_install_packages_thread);
+}
+
+static gboolean
+backend_simulate_install_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	gchar **package_ids;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup_printf ("%s/%s", package_id_data[PK_PACKAGE_ID_DATA], package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* prepare the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_simulate (backend, PACMAN_TRANSACTION_SYNC, flags, list);
+		pacman_list_free_full (list, g_free);
+
+		if (transaction != NULL) {
+			const PacmanList *packages;
+
+			/* emit packages that would have been installed */
+			for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+				PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+				if (backend_cancelled (backend)) {
+					break;
+				} else {
+					backend_package (backend, package, PK_INFO_ENUM_INSTALLING);
+				}
+			}
+		}
+	}
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_simulate_install_packages:
+ **/
+void
+backend_simulate_install_packages (PkBackend *backend, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_simulate_install_packages_thread);
+}
diff -Nru a/backends/pacman/backend-install.h b/backends/pacman/backend-install.h
--- a/backends/pacman/backend-install.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-install.h	2010-04-08 11:47:55.552327140 +1200
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_download_packages		(PkBackend	*backend,
+						 gchar		**package_ids,
+						 const gchar	*directory);
+void	 backend_install_files			(PkBackend	*backend,
+						 gboolean	 only_trusted,
+						 gchar		**full_paths);
+void	 backend_install_packages		(PkBackend	*backend,
+						 gboolean	 only_trusted,
+						 gchar		**package_ids);
+void	 backend_simulate_install_packages	(PkBackend	*backend,
+						 gchar		**package_ids);
diff -Nru a/backends/pacman/backend-packages.c b/backends/pacman/backend-packages.c
--- a/backends/pacman/backend-packages.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-packages.c	2010-04-08 01:06:46.160811294 +1200
@@ -0,0 +1,346 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-groups.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+#include "backend-packages.h"
+
+gchar *
+pacman_package_make_id (PacmanPackage *package)
+{
+	const gchar *name, *version, *arch, *repo;
+	PacmanDatabase *database;
+
+	g_return_val_if_fail (local_database != NULL, NULL);
+	g_return_val_if_fail (package != NULL, NULL);
+
+	name = pacman_package_get_name (package);
+	version = pacman_package_get_version (package);
+
+	arch = pacman_package_get_arch (package);
+	if (arch == NULL) {
+		arch = "any";
+	}
+
+	/* PackageKit requires "local" for package files and "installed" for installed packages */
+	database = pacman_package_get_database (package);
+	if (database == NULL) {
+		repo = "local";
+	} else if (database == local_database) {
+		repo = "installed";
+	} else {
+		repo = pacman_database_get_name (database);
+	}
+
+	return pk_package_id_build (name, version, arch, repo);
+}
+
+void
+backend_package (PkBackend *backend, PacmanPackage *package, PkInfoEnum info)
+{
+	gchar *package_id;
+
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package != NULL);
+
+	/* build and emit package id */
+	package_id = pacman_package_make_id (package);
+	pk_backend_package (backend, info, package_id, pacman_package_get_description (package));
+	g_free (package_id);
+}
+
+PacmanPackage *
+backend_get_package (PkBackend *backend, const gchar *package_id)
+{
+	gchar **package_id_data;
+	const gchar *repo;
+	PacmanDatabase *database;
+	PacmanPackage *package;
+
+	g_return_val_if_fail (pacman != NULL, NULL);
+	g_return_val_if_fail (local_database != NULL, NULL);
+	g_return_val_if_fail (backend != NULL, NULL);
+	g_return_val_if_fail (package_id != NULL, NULL);
+
+	package_id_data = pk_package_id_split (package_id);
+	repo = package_id_data[PK_PACKAGE_ID_DATA];
+
+	/* find the database to search in */
+	if (g_strcmp0 (repo, "installed") == 0) {
+		database = local_database;
+	} else {
+		database = pacman_manager_find_sync_database (pacman, repo);
+	}
+
+	if (database == NULL) {
+		pk_backend_error_code (backend, PK_ERROR_ENUM_REPO_NOT_FOUND, "Could not find repo [%s]", repo);
+		g_strfreev (package_id_data);
+		return NULL;
+	}
+
+	/* find the package in the database */
+	package = pacman_database_find_package (database, package_id_data[PK_PACKAGE_ID_NAME]);
+	if (package == NULL || g_strcmp0 (pacman_package_get_version (package), package_id_data[PK_PACKAGE_ID_VERSION]) != 0) {
+		pk_backend_error_code (backend, PK_ERROR_ENUM_PACKAGE_ID_INVALID, "Could not find package with ID %s", package_id);
+		g_strfreev (package_id_data);
+		return NULL;
+	}
+
+	g_strfreev (package_id_data);
+	return package;
+}
+
+static gboolean
+backend_resolve_thread (PkBackend *backend)
+{
+	guint iterator;
+
+	gchar **package_ids;
+	PkBitfield filters;
+
+	gboolean search_installed;
+	gboolean search_not_installed;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	filters = pk_backend_get_uint (backend, "filters");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	search_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_INSTALLED);
+	search_not_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_NOT_INSTALLED);
+
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		if (backend_cancelled (backend)) {
+			break;
+		}
+
+		/* find a package with the given id or name */
+		if (pk_package_id_check (package_ids[iterator])) {
+			PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+			if (package == NULL) {
+				backend_finished (backend);
+				return FALSE;
+			}
+
+			/* don't emit when not needed */
+			if (pacman_package_get_database (package) == local_database) {
+				if (!search_not_installed) {
+					backend_package (backend, package, PK_INFO_ENUM_INSTALLED);
+				}
+			} else {
+				if (!search_installed) {
+					backend_package (backend, package, PK_INFO_ENUM_AVAILABLE);
+				}
+			}
+		} else {
+			/* find installed packages first */
+			if (!search_not_installed) {
+				PacmanPackage *package = pacman_database_find_package (local_database, package_ids[iterator]);
+
+				if (package != NULL) {
+					backend_package (backend, package, PK_INFO_ENUM_INSTALLED);
+					continue;
+				}
+			}
+
+			if (!search_installed) {
+				const PacmanList *databases;
+
+				for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+					PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+					PacmanPackage *package = pacman_database_find_package (database, package_ids[iterator]);
+
+					if (package != NULL) {
+						backend_package (backend, package, PK_INFO_ENUM_AVAILABLE);
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_resolve:
+ **/
+void
+backend_resolve (PkBackend *backend, PkBitfield filters, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_resolve_thread);
+}
+
+static gboolean
+backend_get_details_thread (PkBackend *backend)
+{
+	guint iterator;
+
+	gchar **package_ids;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* collect details about packages */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package;
+		const PacmanList *list;
+		GString *string;
+
+		gchar *licenses;
+		PkGroupEnum group;
+		const gchar *description, *url;
+		gulong size;
+
+		if (backend_cancelled (backend)) {
+			break;
+		}
+
+		package = backend_get_package (backend, package_ids[iterator]);
+		if (package == NULL) {
+			backend_finished (backend);
+			return FALSE;
+		}
+
+		list = pacman_package_get_licenses (package);
+		if (list == NULL) {
+			string = g_string_new ("unknown");
+		} else {
+			string = g_string_new ((const gchar *) pacman_list_get (list));
+			for (list = pacman_list_next (list); list != NULL; list = pacman_list_next (list)) {
+				/* assume OR although it may not be correct */
+				g_string_append_printf (string, " or %s", (const gchar *) pacman_list_get (list));
+			}
+		}	
+
+		group = pk_group_enum_from_string (pacman_package_get_group (package));
+		description = pacman_package_get_description (package);
+		url = pacman_package_get_url (package);
+
+		if (pacman_package_get_database (package) == local_database) {
+			size = pacman_package_get_installed_size (package);
+		} else {
+			/* FS#18769: change to get_download_size */
+			size = pacman_package_get_size (package);
+		}
+
+		licenses = g_string_free (string, FALSE);
+		pk_backend_details (backend, package_ids[iterator], licenses, group, description, url, size);
+		g_free (licenses);
+	}
+
+	backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_details:
+ **/
+void
+backend_get_details (PkBackend *backend, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_get_details_thread);
+}
+
+static gboolean
+backend_get_files_thread (PkBackend *backend)
+{
+	guint iterator;
+
+	gchar **package_ids;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* enumerate files provided by package */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package;
+		const PacmanList *list;
+
+		GString *string;
+		gchar *files;
+
+		if (backend_cancelled (backend)) {
+			break;
+		}
+
+		package = backend_get_package (backend, package_ids[iterator]);
+		if (package == NULL) {
+			backend_finished (backend);
+			return FALSE;
+		}
+
+		list = pacman_package_get_files (package);
+		if (list == NULL) {
+			string = g_string_new ("");
+		} else {
+			const gchar *root_path = pacman_manager_get_root_path (pacman);
+			string = g_string_new (root_path);
+			g_string_append (string, (const gchar *) pacman_list_get (list));
+
+			for (list = pacman_list_next (list); list != NULL; list = pacman_list_next (list)) {
+				g_string_append_printf (string, ";%s%s", root_path, (const gchar *) pacman_list_get (list));
+			}
+		}	
+
+		files = g_string_free (string, FALSE);
+		pk_backend_files (backend, package_ids[iterator], files);
+		g_free (files);
+	}
+
+	backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_files:
+ **/
+void
+backend_get_files (PkBackend *backend, gchar **package_ids)
+{
+	g_return_if_fail (pacman != NULL);
+	g_return_if_fail (backend != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_get_files_thread);
+}
diff -Nru a/backends/pacman/backend-packages.h b/backends/pacman/backend-packages.h
--- a/backends/pacman/backend-packages.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-packages.h	2010-04-06 02:44:38.703555248 +1200
@@ -0,0 +1,41 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <pk-backend.h>
+
+gchar		*pacman_package_make_id	(PacmanPackage	*package);
+void		 backend_package	(PkBackend	*backend,
+					 PacmanPackage	*package,
+					 PkInfoEnum	 info);
+
+PacmanPackage	*backend_get_package	(PkBackend	*backend,
+					 const gchar	*package_id);
+void		 backend_resolve	(PkBackend	*backend,
+					 PkBitfield	 filters,
+					 gchar		**package_ids);
+
+void		 backend_get_details	(PkBackend	*backend,
+					 gchar		**package_ids);
+void		 backend_get_files	(PkBackend	*backend,
+					 gchar		**package_ids);
diff -Nru a/backends/pacman/backend-pacman.c b/backends/pacman/backend-pacman.c
--- a/backends/pacman/backend-pacman.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-pacman.c	2010-04-08 11:45:41.719006753 +1200
@@ -0,0 +1,256 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+#include <pacman.h>
+
+#include "backend-depends.h"
+#include "backend-error.h"
+#include "backend-groups.h"
+#include "backend-install.h"
+#include "backend-packages.h"
+#include "backend-remove.h"
+#include "backend-repos.h"
+#include "backend-search.h"
+#include "backend-transaction.h"
+#include "backend-update.h"
+#include "backend-pacman.h"
+
+PacmanManager *pacman = NULL;
+GCancellable *cancellable = NULL;
+
+static void
+pacman_message_cb (const gchar *domain, GLogLevelFlags level, const gchar *message, gpointer user_data)
+{
+	g_return_if_fail (message != NULL);
+	g_return_if_fail (user_data != NULL);
+
+	/* report important output to PackageKit */
+	switch (level) {
+		case G_LOG_LEVEL_WARNING:
+		case G_LOG_LEVEL_MESSAGE:
+			egg_warning ("pacman: %s", message);
+			backend_message ((PkBackend *) user_data, message);
+			break;
+
+		case G_LOG_LEVEL_INFO:
+		case G_LOG_LEVEL_DEBUG:
+			egg_debug ("pacman: %s", message);
+			break;
+
+		default:
+			break;
+	}
+}
+
+/**
+ * backend_initialize:
+ **/
+static void
+backend_initialize (PkBackend *backend)
+{
+	GError *error = NULL;
+	GLogLevelFlags flags = G_LOG_LEVEL_WARNING | G_LOG_LEVEL_MESSAGE | G_LOG_LEVEL_INFO | G_LOG_LEVEL_DEBUG;
+
+	g_return_if_fail (backend != NULL);
+
+	/* handle output from pacman */
+	g_log_set_handler ("Pacman", flags, pacman_message_cb, backend);
+
+	/* PATH needs to be set for install scriptlets */
+	g_setenv ("PATH", PACMAN_DEFAULT_PATH, FALSE);
+
+	egg_debug ("pacman: initializing");
+
+	/* initialize pacman-glib */
+	pacman = pacman_manager_get (&error);
+	if (pacman == NULL) {
+		egg_error ("pacman: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+
+	/* disable the relevant databases */
+	if (!backend_initialize_databases (backend, &error)) {
+		egg_error ("pacman: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+
+	/* read group translations from config file */
+	if (!backend_initialize_groups (backend, &error)) {
+		egg_error ("pacman: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+
+	/* setup better download progress reporting */
+	if (!backend_initialize_downloads (backend, &error)) {
+		egg_error ("pacman: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+}
+
+/**
+ * backend_destroy:
+ **/
+static void
+backend_destroy (PkBackend *backend)
+{
+	g_return_if_fail (backend != NULL);
+
+	egg_debug ("pacman: cleaning up");
+
+	backend_destroy_downloads (backend);
+	backend_destroy_groups (backend);
+	backend_destroy_databases (backend);
+
+	if (pacman != NULL) {
+		g_object_unref (pacman);
+	}
+}
+
+/**
+ * backend_get_filters:
+ **/
+static PkBitfield
+backend_get_filters (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, 0);
+
+	return pk_bitfield_from_enums (PK_FILTER_ENUM_INSTALLED, -1);
+}
+
+/**
+ * backend_get_mime_types:
+ **/
+static gchar *
+backend_get_mime_types (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, NULL);
+
+	/* packages currently use .pkg.tar.gz and .pkg.tar.xz */
+	return g_strdup ("application/x-compressed-tar;application/x-xz-compressed-tar");
+}
+
+void
+backend_run (PkBackend *backend, PkStatusEnum status, PkBackendThreadFunc func)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (func != NULL);
+
+	if (cancellable != NULL) {
+		egg_warning ("pacman: cancellable was not NULL");
+		g_object_unref (cancellable);
+	}
+	cancellable = g_cancellable_new ();
+	pk_backend_set_allow_cancel (backend, TRUE);
+
+	pk_backend_set_status (backend, status);
+	pk_backend_thread_create (backend, func);
+}
+
+/**
+ * backend_cancel:
+ **/
+static void
+backend_cancel (PkBackend *backend)
+{
+	g_return_if_fail (backend != NULL);
+
+	if (cancellable != NULL) {
+		g_cancellable_cancel (cancellable);
+	}
+}
+
+gboolean
+backend_cancelled (PkBackend *backend)
+{
+	g_return_val_if_fail (cancellable != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	if (g_cancellable_is_cancelled (cancellable)) {
+		pk_backend_set_status (backend, PK_STATUS_ENUM_CANCEL);
+		return TRUE;
+	} else {
+		return FALSE;
+	}
+}
+
+void
+backend_finished (PkBackend *backend)
+{
+	g_return_if_fail (backend != NULL);
+
+	pk_backend_set_allow_cancel (backend, FALSE);
+	if (cancellable != NULL) {
+		g_object_unref (cancellable);
+		cancellable = NULL;
+	}
+
+	pk_backend_thread_finished (backend);
+}
+
+PK_BACKEND_OPTIONS (
+	"pacman",				/* description */
+	"Jonathan Conder <j@skurvy.no-ip.org>",	/* author */
+	backend_initialize,			/* initialize */
+	backend_destroy,			/* destroy */
+	backend_get_groups,			/* get_groups */
+	backend_get_filters,			/* get_filters */
+	NULL,					/* get_roles */
+	backend_get_mime_types,			/* get_mime_types */
+	backend_cancel,				/* cancel */
+	backend_download_packages,		/* download_packages */
+	NULL,					/* get_categories */
+	backend_get_depends,			/* get_depends */
+	backend_get_details,			/* get_details */
+	NULL,					/* get_distro_upgrades */
+	backend_get_files,			/* get_files */
+	backend_get_packages,			/* get_packages */
+	backend_get_repo_list,			/* get_repo_list */
+	backend_get_requires,			/* get_requires */
+	backend_get_update_detail,		/* get_update_detail */
+	backend_get_updates,			/* get_updates */
+	backend_install_files,			/* install_files */
+	backend_install_packages,		/* install_packages */
+	NULL,					/* install_signature */
+	backend_refresh_cache,			/* refresh_cache */
+	backend_remove_packages,		/* remove_packages */
+	backend_repo_enable,			/* repo_enable */
+	NULL,					/* repo_set_data */
+	backend_resolve,			/* resolve */
+	NULL,					/* rollback */
+	backend_search_details,			/* search_details */
+	backend_search_files,			/* search_files */
+	backend_search_groups,			/* search_groups */
+	backend_search_names,			/* search_names */
+	backend_update_packages,		/* update_packages */
+	backend_update_system,			/* update_system */
+	backend_what_provides,			/* what_provides */
+	NULL,					/* simulate_install_files */
+	backend_simulate_install_packages,	/* simulate_install_packages */
+	backend_simulate_remove_packages,	/* simulate_remove_packages */
+	backend_simulate_update_packages	/* simulate_update_packages */
+);
diff -Nru a/backends/pacman/backend-pacman.h b/backends/pacman/backend-pacman.h
--- a/backends/pacman/backend-pacman.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-pacman.h	2010-04-08 01:05:31.451296614 +1200
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <gio/gio.h>
+#include <pacman.h>
+#include <pk-backend.h>
+
+extern PacmanManager	*pacman;
+extern GCancellable	*cancellable;
+
+void		 backend_run		(PkBackend		*backend,
+					 PkStatusEnum		 status,
+					 PkBackendThreadFunc	 func);
+gboolean	 backend_cancelled	(PkBackend		*backend);
+void		 backend_finished	(PkBackend		*backend);
diff -Nru a/backends/pacman/backend-remove.c b/backends/pacman/backend-remove.c
--- a/backends/pacman/backend-remove.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-remove.c	2010-04-08 12:14:03.885496989 +1200
@@ -0,0 +1,153 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-error.h"
+#include "backend-packages.h"
+#include "backend-pacman.h"
+#include "backend-transaction.h"
+#include "backend-remove.h"
+
+static gboolean
+backend_remove_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	gchar **package_ids;
+	gboolean allow_deps;
+	gboolean autoremove;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	allow_deps = pk_backend_get_bool (backend, "allow_deps");
+	autoremove = pk_backend_get_bool (backend, "autoremove");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* remove packages that depend on those to be removed */
+	if (allow_deps) {
+		flags |= PACMAN_TRANSACTION_FLAGS_REMOVE_CASCADE;
+	}
+	/* remove unneeded packages that were required by those to be removed */
+	if (autoremove) {
+		flags |= PACMAN_TRANSACTION_FLAGS_REMOVE_RECURSIVE;
+	}
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup (package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_REMOVE, flags, list);
+		pacman_list_free_full (list, g_free);
+	}
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_remove_packages:
+ **/
+void
+backend_remove_packages (PkBackend *backend, gchar **package_ids, gboolean allow_deps, gboolean autoremove)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_remove_packages_thread);
+}
+
+static gboolean
+backend_simulate_remove_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	gchar **package_ids;
+	gboolean autoremove;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_REMOVE_CASCADE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	autoremove = pk_backend_get_bool (backend, "autoremove");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* remove unneeded packages that were required by those to be removed */
+	if (autoremove) {
+		flags |= PACMAN_TRANSACTION_FLAGS_REMOVE_RECURSIVE;
+	}
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup (package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* prepare the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_simulate (backend, PACMAN_TRANSACTION_REMOVE, flags, list);
+		pacman_list_free_full (list, g_free);
+
+		if (transaction != NULL) {
+			const PacmanList *packages;
+
+			/* emit packages that would have been removed */
+			for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+				PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+				if (backend_cancelled (backend)) {
+					break;
+				} else {
+					backend_package (backend, package, PK_INFO_ENUM_REMOVING);
+				}
+			}
+		}
+	}
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_simulate_remove_packages:
+ **/
+void
+backend_simulate_remove_packages (PkBackend *backend, gchar **package_ids, gboolean autoremove)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_simulate_remove_packages_thread);
+}
diff -Nru a/backends/pacman/backend-remove.h b/backends/pacman/backend-remove.h
--- a/backends/pacman/backend-remove.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-remove.h	2010-04-06 02:44:38.703555248 +1200
@@ -0,0 +1,32 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_remove_packages		(PkBackend	*backend,
+						 gchar		**package_ids,
+						 gboolean	 allow_deps,
+						 gboolean	 autoremove);
+void	 backend_simulate_remove_packages	(PkBackend	*backend,
+						 gchar		**package_ids,
+						 gboolean	 autoremove);
diff -Nru a/backends/pacman/backend-repos.c b/backends/pacman/backend-repos.c
--- a/backends/pacman/backend-repos.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-repos.c	2010-04-08 12:13:26.506338625 +1200
@@ -0,0 +1,331 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <gio/gio.h>
+#include "backend-error.h"
+#include "backend-pacman.h"
+#include "backend-transaction.h"
+#include "backend-repos.h"
+
+PacmanDatabase *local_database = NULL;
+static GHashTable *disabled_repos = NULL;
+
+static GHashTable *
+disabled_repos_new (GError **error)
+{
+	GHashTable *disabled;
+	GFile *file;
+
+	GFileInputStream *file_stream;
+	GDataInputStream *data_stream;
+
+	gchar *line;
+	GError *e = NULL;
+
+	egg_debug ("pacman: reading disabled repos from %s", PACMAN_REPO_LIST);
+	file = g_file_new_for_path (PACMAN_REPO_LIST);
+	file_stream = g_file_read (file, NULL, &e);
+
+	if (file_stream == NULL) {
+		g_object_unref (file);
+		g_propagate_error (error, e);
+		return NULL;
+	}
+
+	disabled = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+	data_stream = g_data_input_stream_new (G_INPUT_STREAM (file_stream));
+
+	/* read disabled repos line by line, ignoring comments */
+	while ((line = g_data_input_stream_read_line (data_stream, NULL, NULL, &e)) != NULL) {
+		g_strstrip (line);
+
+		if (*line == '\0' || *line == '#') {
+			g_free (line);
+			continue;
+		}
+
+		g_hash_table_insert (disabled, line, GINT_TO_POINTER (1));
+	}
+
+	g_object_unref (data_stream);
+	g_object_unref (file_stream);
+	g_object_unref (file);
+
+	if (e != NULL) {
+		g_hash_table_unref (disabled);
+		g_propagate_error (error, e);
+		return NULL;
+	} else {
+		return disabled;
+	}
+}
+
+static gboolean
+disabled_repos_configure (GHashTable *disabled, GError **error)
+{
+	const PacmanList *databases;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+
+	egg_debug ("pacman: reading config from %s", PACMAN_CONFIG_FILE);
+
+	/* read configuration from pacman config file */
+	if (!pacman_manager_configure (pacman, PACMAN_CONFIG_FILE, error)) {
+		return FALSE;
+	}
+
+	local_database = pacman_manager_get_local_database (pacman);
+
+	/* disable disabled repos */
+	for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+		PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+		const gchar *repo = pacman_database_get_name (database);
+
+		if (g_hash_table_lookup (disabled, repo) != NULL) {
+			if (!pacman_manager_unregister_database (pacman, database, error)) {
+				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+static void
+disabled_repos_free (GHashTable *disabled)
+{
+	GHashTableIter iter;
+	GFile *file;
+
+	GFileOutputStream *file_stream;
+	GDataOutputStream *data_stream;
+
+	const gchar *line = PACMAN_REPO_LIST_HEADER "\n";
+
+	g_return_if_fail (disabled != NULL);
+
+	egg_debug ("pacman: storing disabled repos in %s", PACMAN_REPO_LIST);
+	file = g_file_new_for_path (PACMAN_REPO_LIST);
+	file_stream = g_file_replace (file, NULL, FALSE, G_FILE_CREATE_NONE, NULL, NULL);
+
+	if (file_stream == NULL) {
+		g_object_unref (file);
+		g_hash_table_unref (disabled);
+		return;
+	}
+
+	g_hash_table_iter_init (&iter, disabled);
+	data_stream = g_data_output_stream_new (G_OUTPUT_STREAM (file_stream));
+
+	/* write header, then all disabled repos line by line */
+	if (g_data_output_stream_put_string (data_stream, line, NULL, NULL)) {
+		while (g_hash_table_iter_next (&iter, (gpointer *) &line, NULL) &&
+			g_data_output_stream_put_string (data_stream, line, NULL, NULL) &&
+			g_data_output_stream_put_string (data_stream, "\n", NULL, NULL));
+	}
+
+	g_object_unref (data_stream);
+	g_object_unref (file_stream);
+	g_object_unref (file);
+	g_hash_table_unref (disabled);
+}
+
+gboolean
+backend_initialize_databases (PkBackend *backend, GError **error)
+{
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	disabled_repos = disabled_repos_new (error);
+	if (disabled_repos == NULL) {
+		return FALSE;
+	}
+
+	if (!disabled_repos_configure (disabled_repos, error)) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+void
+backend_destroy_databases (PkBackend *backend)
+{
+	g_return_if_fail (backend != NULL);
+
+	if (disabled_repos != NULL) {
+		disabled_repos_free (disabled_repos);
+	}
+}
+
+static gboolean
+backend_get_repo_list_thread (PkBackend *backend)
+{
+	const PacmanList *databases;
+	GHashTableIter iter;
+	gpointer key, value;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (disabled_repos != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	/* emit enabled repos */
+	for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+		PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+		const gchar *repo = pacman_database_get_name (database);
+
+		if (backend_cancelled (backend)) {
+			break;
+		} else {
+			pk_backend_repo_detail (backend, repo, repo, TRUE);
+		}
+	}
+
+	/* emit disabled repos */
+	g_hash_table_iter_init (&iter, disabled_repos);
+	while (g_hash_table_iter_next (&iter, &key, &value)) {
+		const gchar *repo = (const gchar *) key;
+
+		if (backend_cancelled (backend)) {
+			break;
+		} else {
+			pk_backend_repo_detail (backend, repo, repo, FALSE);
+		}
+	}
+
+	backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_repo_list:
+ **/
+void
+backend_get_repo_list (PkBackend *backend, PkBitfield filters)
+{
+	g_return_if_fail (backend != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_get_repo_list_thread);
+}
+
+static gboolean
+backend_repo_enable_thread (PkBackend *backend)
+{
+	GError *error = NULL;
+
+	const gchar *repo;
+	gboolean enabled;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (disabled_repos != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	repo = pk_backend_get_string (backend, "repo");
+	enabled = pk_backend_get_bool (backend, "enabled");
+
+	g_return_val_if_fail (repo != NULL, FALSE);
+
+	if (enabled) {
+		/* register database if repo is actually disabled */
+		if (g_hash_table_remove (disabled_repos, repo)) {
+			if (disabled_repos_configure (disabled_repos, &error)) {
+				pk_backend_repo_list_changed (backend);
+			} else {
+				backend_error (backend, error);
+				pk_backend_thread_finished (backend);
+				return FALSE;
+			}
+		} else {
+			pk_backend_error_code (backend, PK_ERROR_ENUM_REPO_NOT_FOUND, "Could not find repo [%s]", repo);
+			pk_backend_thread_finished (backend);
+			return FALSE;
+		}
+	} else {
+		PacmanDatabase *database = pacman_manager_find_sync_database (pacman, repo);
+
+		if (database != NULL) {
+			if (pacman_manager_unregister_database (pacman, database, &error)) {
+				g_hash_table_insert (disabled_repos, g_strdup (repo), GINT_TO_POINTER (1));
+			} else {
+				backend_error (backend, error);
+				pk_backend_thread_finished (backend);
+				return FALSE;
+			}
+		} else {
+			pk_backend_error_code (backend, PK_ERROR_ENUM_REPO_NOT_FOUND, "Could not find repo [%s]", repo);
+			pk_backend_thread_finished (backend);
+			return FALSE;
+		}
+	}
+
+	pk_backend_thread_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_repo_enable:
+ **/
+void
+backend_repo_enable (PkBackend *backend, const gchar *repo, gboolean enabled)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (repo != NULL);
+
+	/* setup manually since we can't cancel */
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+	pk_backend_thread_create (backend, backend_repo_enable_thread);
+}
+
+static gboolean
+backend_refresh_cache_thread (PkBackend *backend)
+{
+	gboolean force;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	force = pk_backend_get_bool (backend, "force");
+
+	/* download databases even if they are older than current */
+	if (force) {
+		flags |= PACMAN_TRANSACTION_FLAGS_UPDATE_ALLOW_DOWNGRADE;
+	}
+
+	/* run the transaction */
+	transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_UPDATE, flags, NULL);
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_refresh_cache:
+ **/
+void
+backend_refresh_cache (PkBackend *backend, gboolean force)
+{
+	g_return_if_fail (backend != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_refresh_cache_thread);
+}
diff -Nru a/backends/pacman/backend-repos.h b/backends/pacman/backend-repos.h
--- a/backends/pacman/backend-repos.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-repos.h	2010-04-07 19:32:26.804763488 +1200
@@ -0,0 +1,40 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <pk-backend.h>
+
+extern PacmanDatabase	*local_database;
+
+gboolean	 backend_initialize_databases	(PkBackend	*backend,
+						 GError		**error);
+void		 backend_destroy_databases	(PkBackend	*backend);
+
+void		 backend_get_repo_list		(PkBackend	*backend,
+						 PkBitfield	 filters);
+void		 backend_repo_enable		(PkBackend	*backend,
+						 const gchar	*repo,
+						 gboolean	 enabled);
+
+void		 backend_refresh_cache		(PkBackend	*backend,
+						 gboolean	 force);
diff -Nru a/backends/pacman/backend-search.c b/backends/pacman/backend-search.c
--- a/backends/pacman/backend-search.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-search.c	2010-04-08 01:07:15.437111841 +1200
@@ -0,0 +1,496 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <string.h>
+#include <pacman.h>
+#include "backend-error.h"
+#include "backend-groups.h"
+#include "backend-packages.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+#include "backend-search.h"
+
+static gboolean
+pacman_package_is_installed (PacmanPackage *package)
+{
+	PacmanPackage *installed;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (package != NULL, FALSE);
+
+	/* find an installed package with the same name */
+	installed = pacman_database_find_package (local_database, pacman_package_get_name (package));
+	if (installed == NULL) {
+		return FALSE;
+	}
+
+	/* make sure the installed version is the same */
+	if (pacman_package_compare_version (pacman_package_get_version (installed), pacman_package_get_version (package)) != 0) {
+		return FALSE;
+	}
+
+	/* make sure the installed arch is the same */
+	if (g_strcmp0 (pacman_package_get_arch (installed), pacman_package_get_arch (package)) != 0) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static gboolean
+backend_match_all (PacmanPackage *package, const gchar *needle)
+{
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (needle != NULL, FALSE);
+
+	/* match all packages */
+	return TRUE;
+}
+
+static gboolean
+backend_match_details (PacmanPackage *package, GRegex *regex)
+{
+	const gchar *description;
+	PacmanDatabase *database;
+	const PacmanList *licenses;
+
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (regex != NULL, FALSE);
+
+	/* match the name first... */
+	if (g_regex_match (regex, pacman_package_get_name (package), 0, NULL)) {
+		return TRUE;
+	}
+
+	/* ... then the description... */
+	description = pacman_package_get_description (package);
+	if (description != NULL && g_regex_match (regex, description, 0, NULL)) {
+		return TRUE;
+	}
+
+	/* ... then the database... */
+	database = pacman_package_get_database (package);
+	if (database != NULL && g_regex_match (regex, pacman_database_get_name (database), G_REGEX_MATCH_ANCHORED, NULL)) {
+		return TRUE;
+	}
+
+	/* ... then the licenses */
+	for (licenses = pacman_package_get_licenses (package); licenses != NULL; licenses = pacman_list_next (licenses)) {
+		const gchar *license = (const gchar *) pacman_list_get (licenses);
+		if (g_regex_match (regex, license, G_REGEX_MATCH_ANCHORED, NULL)) {
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static gboolean
+backend_match_file (PacmanPackage *package, const gchar *needle)
+{
+	const PacmanList *files;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (needle != NULL, FALSE);
+
+	/* match any file the package contains */
+	if (G_IS_DIR_SEPARATOR (*needle)) {
+		const gchar *path = pacman_manager_get_root_path (pacman);
+		gsize length = strlen (path);
+
+		for (files = pacman_package_get_files (package); files != NULL; files = pacman_list_next (files)) {
+			const gchar *file = (const gchar *) pacman_list_get (files);
+			if (strncmp (path, needle, length) == 0 && strcmp (file, needle + length) == 0) {
+				return TRUE;
+			}
+		}
+	} else {
+		for (files = pacman_package_get_files (package); files != NULL; files = pacman_list_next (files)) {
+			const gchar *file = (const gchar *) pacman_list_get (files);
+			file = strrchr (file, G_DIR_SEPARATOR);
+
+			if (file != NULL && strcmp (file + 1, needle) == 0) {
+				return TRUE;
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+static gboolean
+backend_match_group (PacmanPackage *package, const gchar *needle)
+{
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (needle != NULL, FALSE);
+
+	/* match the group the package is in */
+	return g_strcmp0 (needle, pacman_package_get_group (package)) == 0;
+}
+
+static gboolean
+backend_match_name (PacmanPackage *package, GRegex *regex)
+{
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (regex != NULL, FALSE);
+
+	/* match the name of the package */
+	return g_regex_match (regex, pacman_package_get_name (package), 0, NULL);
+}
+
+static gboolean
+backend_match_provides (PacmanPackage *package, const gchar *needle)
+{
+	/* TODO: implement GStreamer codecs, Pango fonts, etc. */
+	const PacmanList *provides;
+
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (needle != NULL, FALSE);
+
+	/* match features provided by package */
+	for (provides = pacman_package_get_provides (package); provides != NULL; provides = pacman_list_next (provides)) {
+		const gchar *name = (const gchar *) pacman_list_get (provides);
+		if (g_strcmp0 (needle, name) == 0) {
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+typedef enum {
+	SEARCH_TYPE_ALL,
+	SEARCH_TYPE_DETAILS,
+	SEARCH_TYPE_FILES,
+	SEARCH_TYPE_GROUP,
+	SEARCH_TYPE_NAME,
+	SEARCH_TYPE_PROVIDES,
+	SEARCH_TYPE_LAST
+} SearchType;
+
+typedef gboolean (*MatchFunc) (PacmanPackage *package, const gchar *needle);
+typedef gboolean (*RegexMatchFunc) (PacmanPackage *package, GRegex *regex);
+
+static MatchFunc match_funcs[] = {
+	backend_match_all,
+	NULL,
+	backend_match_file,
+	backend_match_group,
+	NULL,
+	backend_match_provides
+};
+
+static RegexMatchFunc regex_match_funcs[] = {
+	NULL,
+	backend_match_details,
+	NULL,
+	NULL,
+	backend_match_name,
+	NULL
+};
+
+static void
+backend_search_database (PkBackend *backend, PacmanDatabase *database, gchar **search, MatchFunc match)
+{
+	guint iterator;
+	const PacmanList *packages;
+
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (database != NULL);
+	g_return_if_fail (search != NULL);
+	g_return_if_fail (match != NULL);
+
+	/* emit packages that match all search terms */
+	for (packages = pacman_database_get_packages (database); packages != NULL; packages = pacman_list_next (packages)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+		if (backend_cancelled (backend)) {
+			break;
+		}
+
+		for (iterator = 0; search[iterator] != NULL; ++iterator) {
+			if (!match (package, search[iterator])) {
+				break;
+			}
+		}
+
+		/* all search terms matched */
+		if (search[iterator] == NULL) {
+			if (database == local_database) {
+				backend_package (backend, package, PK_INFO_ENUM_INSTALLED);
+			} else if (!pacman_package_is_installed (package)) {
+				backend_package (backend, package, PK_INFO_ENUM_AVAILABLE);
+			}
+		}
+	}
+}
+
+static void
+backend_regex_search_database (PkBackend *backend, PacmanDatabase *database, const PacmanList *regexes, RegexMatchFunc match)
+{
+	const PacmanList *packages, *list;
+
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (database != NULL);
+	g_return_if_fail (regexes != NULL);
+	g_return_if_fail (match != NULL);
+
+	/* emit packages that match all search terms */
+	for (packages = pacman_database_get_packages (database); packages != NULL; packages = pacman_list_next (packages)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+		if (backend_cancelled (backend)) {
+			break;
+		}
+
+		for (list = regexes; list != NULL; list = pacman_list_next (list)) {
+			GRegex *regex = (GRegex *) pacman_list_get (list);
+			if (!match (package, regex)) {
+				break;
+			}
+		}
+
+		/* all search terms matched */
+		if (list == NULL) {
+			if (database == local_database) {
+				backend_package (backend, package, PK_INFO_ENUM_INSTALLED);
+			} else if (!pacman_package_is_installed (package)) {
+				backend_package (backend, package, PK_INFO_ENUM_AVAILABLE);
+			}
+		}
+	}
+}
+
+static gboolean
+backend_search_thread (PkBackend *backend)
+{
+	gchar **search;
+	SearchType search_type;
+	MatchFunc match_func;
+
+	PkBitfield filters;
+	gboolean search_installed;
+	gboolean search_not_installed;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	search = pk_backend_get_strv (backend, "search");
+	search_type = (SearchType) pk_backend_get_uint (backend, "search-type");
+
+	g_return_val_if_fail (search != NULL, FALSE);
+	g_return_val_if_fail (search_type < SEARCH_TYPE_LAST, FALSE);
+
+	match_func = match_funcs[search_type];
+
+	g_return_val_if_fail (match_func != NULL, FALSE);
+
+	filters = pk_backend_get_uint (backend, "filters");
+	search_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_INSTALLED);
+	search_not_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_NOT_INSTALLED);
+
+	/* find installed packages first */
+	if (!search_not_installed) {
+		backend_search_database (backend, local_database, search, match_func);
+	}
+
+	if (!search_installed) {
+		const PacmanList *databases;
+
+		for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+			PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+
+			if (backend_cancelled (backend)) {
+				break;
+			}
+
+			backend_search_database (backend, database, search, match_func);
+		}
+	}
+
+	backend_finished (backend);
+	return TRUE;
+}
+
+static gboolean
+backend_regex_search_thread (PkBackend *backend)
+{
+	gchar **search;
+	SearchType search_type;
+	RegexMatchFunc match_func;
+
+	PkBitfield filters;
+	gboolean search_installed;
+	gboolean search_not_installed;
+
+	guint iterator;
+	PacmanList *regexes = NULL;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	search = pk_backend_get_strv (backend, "search");
+	search_type = (SearchType) pk_backend_get_uint (backend, "search-type");
+
+	g_return_val_if_fail (search != NULL, FALSE);
+	g_return_val_if_fail (search_type < SEARCH_TYPE_LAST, FALSE);
+
+	match_func = regex_match_funcs[search_type];
+
+	g_return_val_if_fail (match_func != NULL, FALSE);
+
+	filters = pk_backend_get_uint (backend, "filters");
+	search_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_INSTALLED);
+	search_not_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_NOT_INSTALLED);
+
+	/* convert search terms to literal regular expressions for fast caseless searching */
+	for (iterator = 0; search[iterator] != NULL; ++iterator) {
+		gchar *pattern;
+		GRegex *regex;
+		GError *error = NULL;
+
+		pattern = g_regex_escape_string (search[iterator], -1);
+		regex = g_regex_new (pattern, G_REGEX_CASELESS, 0, &error);
+		g_free (pattern);
+
+		if (regex != NULL) {
+			regexes = pacman_list_add (regexes, regex);
+		} else {
+			backend_error (backend, error);
+			pacman_list_free_full (regexes, (GDestroyNotify) g_regex_unref);
+			backend_finished (backend);
+			return FALSE;
+		}
+	}
+
+	/* find installed packages first */
+	if (!search_not_installed) {
+		backend_regex_search_database (backend, local_database, regexes, match_func);
+	}
+
+	if (!search_installed) {
+		const PacmanList *databases;
+
+		for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+			PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+
+			if (backend_cancelled (backend)) {
+				break;
+			}
+
+			backend_regex_search_database (backend, database, regexes, match_func);
+		}
+	}
+
+	pacman_list_free_full (regexes, (GDestroyNotify) g_regex_unref);
+
+	backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_packages:
+ **/
+void
+backend_get_packages (PkBackend	*backend, PkBitfield filters)
+{
+	g_return_if_fail (backend != NULL);
+
+	/* provide a dummy needle */
+	pk_backend_set_strv (backend, "search", g_strsplit ("", ";", 0));
+
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_ALL);
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_search_thread);
+}
+
+/**
+ * backend_search_details:
+ **/
+void
+backend_search_details (PkBackend *backend, PkBitfield filters, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_DETAILS);
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_regex_search_thread);
+}
+
+/**
+ * backend_search_files:
+ **/
+void
+backend_search_files (PkBackend *backend, PkBitfield filters, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	/* speed up search by restricting it to local database */
+	pk_bitfield_add (filters, PK_FILTER_ENUM_INSTALLED);
+	pk_backend_set_uint (backend, "filters", filters);
+
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_FILES);
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_search_thread);
+}
+
+/**
+ * backend_search_groups:
+ **/
+void
+backend_search_groups (PkBackend *backend, PkBitfield filters, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_GROUP);
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_search_thread);
+}
+
+/**
+ * backend_search_names:
+ **/
+void
+backend_search_names (PkBackend *backend, PkBitfield filters, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_NAME);
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_regex_search_thread);
+}
+
+/**
+ * backend_what_provides:
+ **/
+void
+backend_what_provides (PkBackend *backend, PkBitfield filters, PkProvidesEnum provides, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_PROVIDES);
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_search_thread);
+}
diff -Nru a/backends/pacman/backend-search.h b/backends/pacman/backend-search.h
--- a/backends/pacman/backend-search.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-search.h	2010-04-07 19:43:42.275532112 +1200
@@ -0,0 +1,43 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_get_packages	(PkBackend	*backend,
+				 PkBitfield	 filters);
+void	 backend_search_details	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**values);
+void	 backend_search_files	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**values);
+void	 backend_search_groups	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**values);
+void	 backend_search_names	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**values);
+void	 backend_what_provides	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 PkProvidesEnum	 provides,
+				 gchar		**values);
diff -Nru a/backends/pacman/backend-transaction.c b/backends/pacman/backend-transaction.c
--- a/backends/pacman/backend-transaction.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-transaction.c	2010-04-12 14:51:32.418028887 +1200
@@ -0,0 +1,501 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <string.h>
+#include "backend-error.h"
+#include "backend-packages.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+#include "backend-transaction.h"
+
+typedef struct {
+	guint complete;
+	guint total;
+
+	PacmanPackage *package;
+	GString *files;
+} BackendDownloadData;
+
+static GHashTable *downloads = NULL;
+
+gboolean
+backend_initialize_downloads (PkBackend *backend, GError **error)
+{
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	downloads = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);
+	return TRUE;
+}
+
+void
+backend_destroy_downloads (PkBackend *backend)
+{
+	g_return_if_fail (backend != NULL);
+
+	if (downloads != NULL) {
+		g_hash_table_unref (downloads);
+	}
+}
+
+static void
+transaction_download_end (PacmanTransaction *transaction, BackendDownloadData *download, PkBackend *backend) {
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (download != NULL);
+	g_return_if_fail (backend != NULL);
+
+	/* emit the finished signal for the old package */
+	backend_package (backend, download->package, PK_INFO_ENUM_FINISHED);
+
+	/* emit the list of files downloaded for DownloadPackages */
+	if (download->files != NULL) {
+		gchar *package_id, *files;
+
+		package_id = pacman_package_make_id (download->package);
+		files = g_string_free (download->files, FALSE);
+
+		pk_backend_files (backend, package_id, files);
+
+		g_free (package_id);
+		g_free (files);
+	}
+
+	download->package = NULL;
+	download->files = NULL;
+}
+
+static gchar *
+backend_filename_make_path (PkBackend *backend, const gchar *filename)
+{
+	const gchar *directory;
+
+	g_return_val_if_fail (backend != NULL, NULL);
+	g_return_val_if_fail (filename != NULL, NULL);
+
+	directory = pk_backend_get_string (backend, "directory");
+
+	g_return_val_if_fail (directory != NULL, NULL);
+
+	return g_build_filename (directory, filename, NULL);
+}
+
+static void
+transaction_download_start (PacmanTransaction *transaction, BackendDownloadData *download, const gchar *filename, PkBackend *backend)
+{
+	const PacmanList *packages;
+
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (download != NULL);
+	g_return_if_fail (filename != NULL);
+	g_return_if_fail (backend != NULL);
+
+	/* continue or finish downloading the old package */
+	if (download->package != NULL) {
+		if (pacman_package_has_filename (download->package, filename)) {
+			if (download->files != NULL) {
+				gchar *path = backend_filename_make_path (backend, filename);
+				g_string_append_printf (download->files, ";%s", path);
+				g_free (path);
+			}
+			return;
+		} else {
+			transaction_download_end (transaction, download, backend);
+		}
+	}
+
+	/* find a new package for the current file */
+	for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+		if (pacman_package_has_filename (package, filename)) {
+			download->package = package;
+			break;
+		}
+	}
+
+	/* emit the downloading signal and start collecting files for the new package */
+	if (download->package != NULL) {
+		backend_package (backend, download->package, PK_INFO_ENUM_DOWNLOADING);
+
+		/* only emit files downloaded for DownloadPackages */
+		if (pk_backend_get_role (backend) == PK_ROLE_ENUM_DOWNLOAD_PACKAGES) {
+			gchar *path = backend_filename_make_path (backend, filename);
+			download->files = g_string_new (path);
+			g_free (path);
+		}
+	}
+}
+
+static void
+transaction_download_cb (PacmanTransaction *transaction, const gchar *filename, guint complete, guint total, gpointer user_data)
+{
+	BackendDownloadData *download;
+
+	g_return_if_fail (pacman != NULL);
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (user_data != NULL);
+
+	download = (BackendDownloadData *) g_hash_table_lookup (downloads, transaction);
+
+	if (filename == NULL) {
+		if (download == NULL) {
+			/* start a new download */
+			download = g_new0 (BackendDownloadData, 1);
+			download->complete = complete;
+			download->total = total;
+			g_hash_table_insert (downloads, transaction, download);
+		} else {
+			/* finish the current download */
+			if (download->package != NULL) {
+				transaction_download_end (transaction, download, (PkBackend *) user_data);
+			}
+			g_hash_table_remove (downloads, transaction);
+		}
+	} else {
+		guint percentage = 100, sub_percentage = 100;
+
+		g_return_if_fail (download != NULL);
+
+		if (total > 0) {
+			sub_percentage = complete * 100 / total;
+		}
+
+		if (strstr (filename, ".db.tar.") != NULL) {
+			const PacmanList *databases = pacman_manager_get_sync_databases (pacman);
+			guint database_total = pacman_list_length (databases);
+
+			/* report download progress for databases */
+			if (database_total > 0) {
+				percentage = (sub_percentage + download->complete * 100) / database_total;
+			}
+
+			if (complete == 0) {
+				egg_debug ("pacman: downloading database %s", filename);
+				pk_backend_set_status ((PkBackend *) user_data, PK_STATUS_ENUM_REFRESH_CACHE);
+			}
+
+			if (complete == total) {
+				download->complete += 1;
+			}
+		} else {
+			/* report download progress for package or delta files */
+			if (download->total > 0) {
+				percentage = (download->complete + complete) * 100 / download->total;
+			}
+
+			if (complete == 0) {
+				egg_debug ("pacman: downloading package %s", filename);
+				pk_backend_set_status ((PkBackend *) user_data, PK_STATUS_ENUM_DOWNLOAD);
+				transaction_download_start (transaction, download, filename, (PkBackend *) user_data);
+			}
+
+			if (complete == total) {
+				download->complete += complete;
+			}
+		}
+
+		pk_backend_set_sub_percentage ((PkBackend *) user_data, sub_percentage);
+		pk_backend_set_percentage ((PkBackend *) user_data, percentage);
+	}
+}
+
+static void
+transaction_progress_cb (PacmanTransaction *transaction, PacmanTransactionProgress type, const gchar *target, guint percent, guint current, guint targets, gpointer user_data)
+{
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (user_data != NULL);
+
+	g_return_if_fail (percent >= 0);
+	g_return_if_fail (percent <= 100);
+	g_return_if_fail (current >= 1);
+	g_return_if_fail (current <= targets);
+
+	/* update transaction progress */
+	switch (type) {
+		case PACMAN_TRANSACTION_PROGRESS_INSTALL:
+		case PACMAN_TRANSACTION_PROGRESS_UPGRADE:
+		case PACMAN_TRANSACTION_PROGRESS_REMOVE:
+		case PACMAN_TRANSACTION_PROGRESS_FILE_CONFLICT_CHECK:
+		{
+			egg_debug ("pacman: progress for %s (%u of %u) is %u%%", target, current, targets, percent);
+			pk_backend_set_sub_percentage ((PkBackend *) user_data, percent);
+			pk_backend_set_percentage ((PkBackend *) user_data, (percent + (current - 1) * 100) / targets);
+			break;
+		}
+		default:
+			egg_debug ("pacman: progress of type %d (%u of %u) is %u%%", type, current, targets, percent);
+			break;
+	}
+}
+
+static gboolean
+transaction_question_cb (PacmanTransaction *transaction, PacmanTransactionQuestion question, const gchar *message, gpointer user_data)
+{
+	g_return_val_if_fail (transaction != NULL, FALSE);
+	g_return_val_if_fail (user_data != NULL, FALSE);
+
+	switch (question) {
+		case PACMAN_TRANSACTION_QUESTION_INSTALL_IGNORE_PACKAGE:
+		{
+			PkRoleEnum role = pk_backend_get_role ((PkBackend *) user_data);
+			if (role == PK_ROLE_ENUM_INSTALL_PACKAGES) {
+				gchar *packages = pacman_package_make_list (pacman_transaction_get_marked_packages (transaction));
+				gchar *warning = g_strdup_printf ("The following packages were marked as ignored:\n%s\n", packages);
+
+				/* ignored packages are blocked in updates, can be explicitly installed */
+				egg_warning ("pacman: %s", warning);
+				backend_message ((PkBackend *) user_data, warning);
+
+				g_free (warning);
+				g_free (packages);
+				return TRUE;
+			} else if (role == PK_ROLE_ENUM_SIMULATE_INSTALL_PACKAGES) {
+				return TRUE;
+			} else if (role == PK_ROLE_ENUM_GET_UPDATES) {
+				const PacmanList *packages;
+
+				for (packages = pacman_transaction_get_marked_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+					PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+					backend_package ((PkBackend *) user_data, package, PK_INFO_ENUM_BLOCKED);
+				}
+
+				return FALSE;
+			} else {
+				return FALSE;
+			}
+		}
+		case PACMAN_TRANSACTION_QUESTION_SKIP_UNRESOLVABLE_PACKAGES:
+		{
+			PkRoleEnum role = pk_backend_get_role ((PkBackend *) user_data);
+			if (role == PK_ROLE_ENUM_GET_UPDATES) {
+				const PacmanList *packages;
+
+				for (packages = pacman_transaction_get_marked_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+					PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+					backend_package ((PkBackend *) user_data, package, PK_INFO_ENUM_BLOCKED);
+				}
+
+				return TRUE;
+			} else if (role == PK_ROLE_ENUM_UPDATE_SYSTEM) {
+				return TRUE;
+			} else {
+				return FALSE;
+			}
+		}
+		case PACMAN_TRANSACTION_QUESTION_REMOVE_CONFLICTING_PACKAGE:
+		case PACMAN_TRANSACTION_QUESTION_REMOVE_HOLD_PACKAGES:
+			/* none of these actions are safe */
+			egg_warning ("pacman: ignoring question '%s'", message);
+			return FALSE;
+
+		case PACMAN_TRANSACTION_QUESTION_REPLACE_PACKAGE:
+		case PACMAN_TRANSACTION_QUESTION_INSTALL_OLDER_PACKAGE:
+		case PACMAN_TRANSACTION_QUESTION_DELETE_CORRUPTED_PACKAGE:
+		case PACMAN_TRANSACTION_QUESTION_SYNC_FIRST:
+			/* these actions are mostly harmless */
+			egg_warning ("pacman: confirming question '%s'", message);
+			return TRUE;
+
+		default:
+			egg_warning ("pacman: unrecognised question '%s'", message);
+			return FALSE;
+	}
+}
+
+static void
+transaction_status_cb (PacmanTransaction *transaction, PacmanTransactionStatus status, const gchar *message, gpointer user_data)
+{
+	PkStatusEnum state;
+	PkInfoEnum info;
+
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (user_data != NULL);
+
+	/* figure out the backend status and package info */
+	switch (status) {
+		case PACMAN_TRANSACTION_STATUS_INSTALL_START:
+			state = PK_STATUS_ENUM_INSTALL;
+			info = PK_INFO_ENUM_INSTALLING;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_UPGRADE_START:
+			state = PK_STATUS_ENUM_UPDATE;
+			info = PK_INFO_ENUM_UPDATING;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_REMOVE_START:
+			state = PK_STATUS_ENUM_REMOVE;
+			info = PK_INFO_ENUM_REMOVING;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_INSTALL_END:
+		case PACMAN_TRANSACTION_STATUS_UPGRADE_END:
+		case PACMAN_TRANSACTION_STATUS_REMOVE_END:
+			state = PK_STATUS_ENUM_UNKNOWN;
+			info = PK_INFO_ENUM_FINISHED;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_DEPENDENCY_CHECK_START:
+		case PACMAN_TRANSACTION_STATUS_DEPENDENCY_RESOLVE_START:
+			state = PK_STATUS_ENUM_DEP_RESOLVE;
+			info = PK_INFO_ENUM_UNKNOWN;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_FILE_CONFLICT_CHECK_START:
+		case PACMAN_TRANSACTION_STATUS_CONFLICT_CHECK_START:
+		case PACMAN_TRANSACTION_STATUS_PACKAGE_INTEGRITY_CHECK_START:
+		case PACMAN_TRANSACTION_STATUS_DELTA_INTEGRITY_CHECK_START:
+			state = PK_STATUS_ENUM_TEST_COMMIT;
+			info = PK_INFO_ENUM_UNKNOWN;
+			break;
+
+		default:
+			state = PK_STATUS_ENUM_UNKNOWN;
+			info = PK_INFO_ENUM_UNKNOWN;
+			egg_debug ("pacman: %s", message);
+			break;
+	}
+
+	/* update the backend status */
+	if (state != PK_STATUS_ENUM_UNKNOWN) {
+		pk_backend_set_status ((PkBackend *) user_data, state);
+	}
+
+	/* update the package info */
+	if (info != PK_INFO_ENUM_UNKNOWN) {
+		const PacmanList *packages;
+
+		for (packages = pacman_transaction_get_marked_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+			PacmanPackage *package;
+
+			/* only report the old versions */
+			if (status == PACMAN_TRANSACTION_STATUS_UPGRADE_START || status == PACMAN_TRANSACTION_STATUS_UPGRADE_END) {
+				packages = pacman_list_next (packages);
+				if (packages == NULL) {
+					break;
+				}
+			}
+
+			package = (PacmanPackage *) pacman_list_get (packages);
+			backend_package ((PkBackend *) user_data, package, info);
+		}
+	}
+}
+
+static void
+transaction_cancelled_cb (GCancellable *object, gpointer user_data)
+{
+	g_return_if_fail (user_data != NULL);
+
+	pacman_transaction_cancel ((PacmanTransaction *) user_data, NULL);
+}
+
+PacmanTransaction *
+backend_transaction_simulate (PkBackend *backend, PacmanTransactionType type, guint32 flags, const PacmanList *targets)
+{
+	PacmanTransaction *transaction;
+	GError *error = NULL;
+
+	g_return_val_if_fail (pacman != NULL, NULL);
+	g_return_val_if_fail (cancellable != NULL, NULL);
+	g_return_val_if_fail (backend != NULL, NULL);
+	g_return_val_if_fail (type < PACMAN_TRANSACTION_LAST, NULL);
+
+	switch (type) {
+		case PACMAN_TRANSACTION_INSTALL:
+			transaction = pacman_manager_install (pacman, flags, &error);
+			break;
+		case PACMAN_TRANSACTION_REMOVE:
+			transaction = pacman_manager_remove (pacman, flags, &error);
+			break;
+		case PACMAN_TRANSACTION_SYNC:
+			transaction = pacman_manager_sync (pacman, flags, &error);
+			break;
+		case PACMAN_TRANSACTION_UPDATE:
+			transaction = pacman_manager_update (pacman, flags, &error);
+			break;
+		default:
+			g_return_val_if_reached (NULL);
+	}
+
+	if (transaction == NULL) {
+		backend_error (backend, error);
+		return NULL;
+	}
+
+	g_signal_connect (transaction, "download", G_CALLBACK (transaction_download_cb), backend);
+	g_signal_connect (transaction, "progress", G_CALLBACK (transaction_progress_cb), backend);
+	g_signal_connect (transaction, "question", G_CALLBACK (transaction_question_cb), backend);
+	g_signal_connect (transaction, "status", G_CALLBACK (transaction_status_cb), backend);
+
+	if (g_cancellable_connect (cancellable, G_CALLBACK (transaction_cancelled_cb), transaction, NULL) == 0 && backend_cancelled (backend)) {
+		return transaction;
+	}
+
+	if (!pacman_transaction_prepare (transaction, targets, &error)) {
+		backend_error (backend, error);
+		g_object_unref (transaction);
+		return NULL;
+	}
+
+	return transaction;
+}
+
+PacmanTransaction *
+backend_transaction_run (PkBackend *backend, PacmanTransactionType type, guint32 flags, const PacmanList *targets)
+{
+	PacmanTransaction *transaction;
+	GError *error = NULL;
+
+	g_return_val_if_fail (backend != NULL, NULL);
+
+	transaction = backend_transaction_simulate (backend, type, flags, targets);
+
+	if (backend_cancelled (backend)) {
+		return transaction;
+	} else if (transaction != NULL) {
+		pk_backend_set_status (backend, PK_STATUS_ENUM_RUNNING);
+
+		if (!pacman_transaction_commit (transaction, &error)) {
+			backend_error (backend, error);
+			g_hash_table_remove (downloads, transaction);
+			g_object_unref (transaction);
+			return NULL;
+		}
+	}
+
+	return transaction;
+}
+
+gboolean
+backend_transaction_finished (PkBackend *backend, PacmanTransaction *transaction)
+{
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	if (transaction != NULL) {
+		g_object_unref (transaction);
+		backend_finished (backend);
+		return TRUE;
+	} else {
+		backend_finished (backend);
+		return FALSE;
+	}
+}
diff -Nru a/backends/pacman/backend-transaction.h b/backends/pacman/backend-transaction.h
--- a/backends/pacman/backend-transaction.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-transaction.h	2010-04-08 00:25:55.186345285 +1200
@@ -0,0 +1,49 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <pk-backend.h>
+
+typedef enum {
+	PACMAN_TRANSACTION_INSTALL,
+	PACMAN_TRANSACTION_REMOVE,
+	PACMAN_TRANSACTION_SYNC,
+	PACMAN_TRANSACTION_UPDATE,
+	PACMAN_TRANSACTION_LAST
+} PacmanTransactionType;
+
+gboolean		 backend_initialize_downloads	(PkBackend		*backend,
+							 GError			**error);
+void			 backend_destroy_downloads	(PkBackend		*backend);
+
+PacmanTransaction	*backend_transaction_simulate	(PkBackend		*backend,
+							 PacmanTransactionType	 type,
+							 guint32		 flags,
+							 const PacmanList	*targets);
+PacmanTransaction	*backend_transaction_run	(PkBackend		*backend,
+							 PacmanTransactionType	 type,
+							 guint32		 flags,
+							 const PacmanList	*targets);
+
+gboolean		 backend_transaction_finished	(PkBackend		*backend,
+							 PacmanTransaction	*transaction);
diff -Nru a/backends/pacman/backend-update.c b/backends/pacman/backend-update.c
--- a/backends/pacman/backend-update.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-update.c	2010-04-12 15:39:19.496908370 +1200
@@ -0,0 +1,525 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <glib/gstdio.h>
+#include "backend-error.h"
+#include "backend-pacman.h"
+#include "backend-packages.h"
+#include "backend-repos.h"
+#include "backend-transaction.h"
+#include "backend-update.h"
+
+static gchar *
+pacman_package_make_replaces_ids (PacmanPackage *package)
+{
+	const PacmanList *list;
+	GString *string = NULL;
+
+	g_return_val_if_fail (local_database != NULL, NULL);
+	g_return_val_if_fail (package != NULL, NULL);
+
+	/* make a list of the packages that package replaces */
+	for (list = pacman_package_get_replaces (package); list != NULL; list = pacman_list_next (list)) {
+		const gchar *name = pacman_list_get (list);
+		PacmanPackage *replaces = pacman_database_find_package (local_database, name);
+
+		if (replaces != NULL) {
+			gchar *package_id = pacman_package_make_id (replaces);
+			if (string == NULL) {
+				string = g_string_new (package_id);
+			} else {
+				g_string_append_printf (string, "&%s", package_id);
+			}
+			g_free (package_id);
+		}
+	}
+
+	if (string != NULL) {
+		return g_string_free (string, FALSE);
+	} else {
+		return NULL;
+	}
+}
+
+static gchar *
+pacman_package_make_vendor_url (PacmanPackage *package)
+{
+#ifdef PACMAN_PACKAGE_URL
+	const gchar *name, *arch, *repo, *url;
+#else
+	const gchar *url;
+#endif
+
+	g_return_val_if_fail (package != NULL, NULL);
+
+	/* grab the URL of the package... */
+	url = pacman_package_get_url (package);
+
+#ifdef PACMAN_PACKAGE_URL
+	/* ... and construct the distro URL if possible */
+	name = pacman_package_get_name (package);
+	arch = pacman_package_get_arch (package);
+	repo = pacman_database_get_name (pacman_package_get_database (package));
+
+	return g_strdup_printf ("%s;Package website;" PACMAN_PACKAGE_URL ";Distribution website", url, repo, arch, name);
+#else
+	return g_strdup_printf ("%s;Package website", url);
+#endif
+}
+
+static gboolean
+backend_get_update_detail_thread (PkBackend *backend)
+{
+	guint iterator;
+
+	gchar **package_ids;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* collect details about updates */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package, *upgrades;
+		PacmanDatabase *database;
+
+		gchar *upgrades_id, *replaces_ids, *vendor_url;
+		const gchar *message;
+
+		PkRestartEnum restart;
+		PkUpdateStateEnum state;
+
+		if (backend_cancelled (backend)) {
+			break;
+		}
+
+		package = backend_get_package (backend, package_ids[iterator]);
+		if (package == NULL) {
+			backend_finished (backend);
+			return FALSE;
+		}
+
+		upgrades = pacman_database_find_package (local_database, pacman_package_get_name (package));
+		if (upgrades != NULL) {
+			upgrades_id = pacman_package_make_id (upgrades);
+			message = "Update to latest available version";
+		} else {
+			upgrades_id = NULL;
+			message = "Install as a dependency for another update";
+		}
+
+		database = pacman_package_get_database (package);
+		replaces_ids = pacman_package_make_replaces_ids (package);
+		vendor_url = pacman_package_make_vendor_url (package);
+
+		if (g_str_has_prefix (pacman_package_get_name (package), "kernel")) {
+			restart = PK_RESTART_ENUM_SYSTEM;
+		} else {
+			restart = PK_RESTART_ENUM_NONE;
+		}
+
+		if (g_str_has_suffix (pacman_database_get_name (database), "testing")) {
+			state = PK_UPDATE_STATE_ENUM_TESTING;
+		} else {
+			state = PK_UPDATE_STATE_ENUM_STABLE;
+		}
+
+		pk_backend_update_detail (backend, package_ids[iterator], upgrades_id, replaces_ids, vendor_url, NULL, NULL, restart, message, NULL, state, NULL, NULL);
+
+		g_free (vendor_url);
+		g_free (replaces_ids);
+		g_free (upgrades_id);
+	}
+
+	backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_update_detail:
+ **/
+void
+backend_get_update_detail (PkBackend *backend, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_get_update_detail_thread);
+}
+
+static gboolean
+backend_get_updates_thread (PkBackend *backend)
+{
+	struct stat cache;
+	time_t one_hour_ago;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	time (&one_hour_ago);
+	one_hour_ago -= 60 * 60;
+
+	/* refresh databases if they are older than an hour */
+	if (g_stat (PACMAN_CACHE_PATH, &cache) < 0 || cache.st_mtime < one_hour_ago) {
+		transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_UPDATE, flags, NULL);
+		if (transaction != NULL) {
+			g_object_unref (transaction);
+		} else {
+			backend_finished (backend);
+			return FALSE;
+		}
+	} else {
+		egg_debug ("pacman: databases have been refreshed recently");
+	}
+
+	/* prepare the transaction */
+	transaction = backend_transaction_simulate (backend, PACMAN_TRANSACTION_SYNC, flags, NULL);
+	if (transaction != NULL) {
+		const PacmanList *packages;
+
+		/* emit packages that need updating */
+		for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+			PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+			if (backend_cancelled (backend)) {
+				break;
+			}
+
+			if (pacman_database_find_package (local_database, pacman_package_get_name (package)) != NULL) {
+				backend_package (backend, package, PK_INFO_ENUM_NORMAL);
+			} else if (pacman_package_get_removes (package) != NULL) {
+				backend_package (backend, package, PK_INFO_ENUM_NORMAL);
+			}
+		}
+	}
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_get_updates:
+ **/
+void
+backend_get_updates (PkBackend *backend, PkBitfield filters)
+{
+	g_return_if_fail (backend != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_QUERY, backend_get_updates_thread);
+}
+
+static gboolean
+backend_package_ids_contain_package (gchar **package_ids, PacmanPackage *package)
+{
+	guint iterator;
+	PacmanDatabase *database;
+	const gchar *name, *repo;
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+	g_return_val_if_fail (package != NULL, FALSE);
+
+	database = pacman_package_get_database (package);
+	name = pacman_package_get_name (package);
+	repo = pacman_database_get_name (database);
+
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		if (g_strcmp0 (name, package_id_data[PK_PACKAGE_ID_NAME]) == 0) {
+			if (g_strcmp0 (repo, package_id_data[PK_PACKAGE_ID_DATA]) == 0) {
+				g_strfreev (package_id_data);
+				return TRUE;
+			}
+		}
+		g_strfreev (package_id_data);
+	}
+
+	return FALSE;
+}
+
+static gboolean
+backend_update_packages_thread (PkBackend *backend)
+{
+	PacmanList *install = NULL, *asdeps = NULL, *replace = NULL;
+
+	/* FS#5331: use only_trusted */
+	gchar **package_ids;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags iflags = PACMAN_TRANSACTION_FLAGS_NONE;
+	PacmanTransactionFlags dflags = PACMAN_TRANSACTION_FLAGS_INSTALL_IMPLICIT;
+	PacmanTransactionFlags rflags = PACMAN_TRANSACTION_FLAGS_IGNORE_DEPENDENCIES;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* prepare the update */
+	transaction = backend_transaction_simulate (backend, PACMAN_TRANSACTION_SYNC, iflags, NULL);
+
+	if (transaction != NULL) {
+		const PacmanList *packages;
+
+		/* collect targets to install and replace */
+		for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+			PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+			if (backend_cancelled (backend)) {
+				pacman_list_free_full (install, g_free);
+				pacman_list_free_full (asdeps, g_free);
+				pacman_list_free_full (replace, g_free);
+				backend_finished (backend);
+				return TRUE;
+			}
+
+			if (backend_package_ids_contain_package (package_ids, package)) {
+				PacmanDatabase *database = pacman_package_get_database (package);
+				const gchar *name = pacman_package_get_name (package), *repo = pacman_database_get_name (database);
+				const PacmanList *removes = pacman_package_get_removes (package);
+
+				if (removes != NULL) {
+					for (; removes != NULL; removes = pacman_list_next (removes)) {
+						PacmanPackage *obsolete = (PacmanPackage *) pacman_list_get (removes);
+						replace = pacman_list_add (replace, g_strdup (pacman_package_get_name (obsolete)));
+					}
+
+					if (!pacman_package_was_explicitly_installed (package)) {
+						asdeps = pacman_list_add (asdeps, g_strdup_printf ("%s/%s", repo, name));
+					}
+				}
+
+				install = pacman_list_add (install, g_strdup_printf ("%s/%s", repo, name));
+			}
+		}
+
+		g_object_unref (transaction);
+	} else {
+		backend_finished (backend);
+		return FALSE;
+	}
+
+	/* replace all obsoleted packages */
+	if (replace != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_REMOVE, rflags, replace);
+		pacman_list_free_full (replace, g_free);
+
+		if (transaction != NULL) {
+			g_object_unref (transaction);
+		} else {
+			pacman_list_free_full (install, g_free);
+			pacman_list_free_full (asdeps, g_free);
+			backend_finished (backend);
+			return FALSE;
+		}
+	}
+
+	/* run the transaction */
+	if (install != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_SYNC, iflags, install);
+		pacman_list_free_full (install, g_free);
+
+		if (transaction != NULL) {
+			g_object_unref (transaction);
+		} else {
+			pacman_list_free_full (asdeps, g_free);
+			backend_finished (backend);
+			return FALSE;
+		}
+	}
+
+	/* mark replacements as deps if required */
+	if (asdeps != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_SYNC, dflags, asdeps);
+		pacman_list_free_full (asdeps, g_free);
+	}
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_update_packages:
+ **/
+void
+backend_update_packages (PkBackend *backend, gboolean only_trusted, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_update_packages_thread);
+}
+
+static gboolean
+backend_simulate_update_packages_thread (PkBackend *backend)
+{
+	PacmanList *install = NULL, *replace = NULL;
+
+	gchar **package_ids;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags iflags = PACMAN_TRANSACTION_FLAGS_NONE;
+	PacmanTransactionFlags rflags = PACMAN_TRANSACTION_FLAGS_IGNORE_DEPENDENCIES;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* prepare the update */
+	transaction = backend_transaction_simulate (backend, PACMAN_TRANSACTION_SYNC, iflags, NULL);
+
+	if (transaction != NULL) {
+		const PacmanList *packages;
+
+		/* collect targets to install and replace */
+		for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+			PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+			if (backend_cancelled (backend)) {
+				pacman_list_free_full (install, g_free);
+				pacman_list_free_full (replace, g_free);
+				backend_finished (backend);
+				return TRUE;
+			}
+
+			if (backend_package_ids_contain_package (package_ids, package)) {
+				PacmanDatabase *database = pacman_package_get_database (package);
+				const gchar *name = pacman_package_get_name (package), *repo = pacman_database_get_name (database);
+				const PacmanList *removes = pacman_package_get_removes (package);
+
+				for (; removes != NULL; removes = pacman_list_next (removes)) {
+					PacmanPackage *obsolete = (PacmanPackage *) pacman_list_get (removes);
+					replace = pacman_list_add (replace, g_strdup (pacman_package_get_name (obsolete)));
+				}
+
+				install = pacman_list_add (install, g_strdup_printf ("%s/%s", repo, name));
+			}
+		}
+
+		g_object_unref (transaction);
+	} else {
+		backend_finished (backend);
+		return FALSE;
+	}
+
+	/* prepare to replace all obsoleted packages */
+	if (replace != NULL) {
+		transaction = backend_transaction_simulate (backend, PACMAN_TRANSACTION_REMOVE, rflags, replace);
+		pacman_list_free_full (replace, g_free);
+
+		if (transaction != NULL) {
+			const PacmanList *packages;
+
+			/* emit packages that would have been replaced */
+			for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+				PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+				if (backend_cancelled (backend)) {
+					break;
+				}
+
+				backend_package (backend, package, PK_INFO_ENUM_OBSOLETING);
+			}
+
+			g_object_unref (transaction);
+		} else {
+			pacman_list_free_full (install, g_free);
+			backend_finished (backend);
+			return FALSE;
+		}
+	}
+
+	/* prepare the transaction */
+	if (install != NULL) {
+		transaction = backend_transaction_simulate (backend, PACMAN_TRANSACTION_SYNC, iflags, install);
+		pacman_list_free_full (install, g_free);
+
+		if (transaction != NULL) {
+			const PacmanList *packages;
+
+			/* emit packages that would have been updated */
+			for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+				PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+				if (backend_cancelled (backend)) {
+					break;
+				}
+
+				if (pacman_database_find_package (local_database, pacman_package_get_name (package)) != NULL) {
+					backend_package (backend, package, PK_INFO_ENUM_UPDATING);
+				} else {
+					backend_package (backend, package, PK_INFO_ENUM_INSTALLING);
+				}
+			}
+		}
+	}
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_simulate_update_packages:
+ **/
+void
+backend_simulate_update_packages (PkBackend *backend, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_simulate_update_packages_thread);
+}
+
+static gboolean
+backend_update_system_thread (PkBackend *backend)
+{
+	/* FS#5331: use only_trusted */
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	/* run the transaction */
+	transaction = backend_transaction_run (backend, PACMAN_TRANSACTION_SYNC, flags, NULL);
+
+	return backend_transaction_finished (backend, transaction);
+}
+
+/**
+ * backend_update_system:
+ **/
+void
+backend_update_system (PkBackend *backend, gboolean only_trusted)
+{
+	g_return_if_fail (backend != NULL);
+
+	backend_run (backend, PK_STATUS_ENUM_SETUP, backend_update_system_thread);
+}
diff -Nru a/backends/pacman/backend-update.h b/backends/pacman/backend-update.h
--- a/backends/pacman/backend-update.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-update.h	2010-04-08 11:47:08.032332412 +1200
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_get_update_detail		(PkBackend	*backend,
+						 gchar		**package_ids);
+void	 backend_get_updates			(PkBackend	*backend,
+						 PkBitfield	 filters);
+void	 backend_update_packages		(PkBackend	*backend,
+						 gboolean	 only_trusted,
+						 gchar		**package_ids);
+void	 backend_simulate_update_packages	(PkBackend	*backend,
+						 gchar		**package_ids);
+void	 backend_update_system			(PkBackend	*backend,
+						 gboolean	 only_trusted);
diff -Nru a/backends/pacman/groups.list b/backends/pacman/groups.list
--- a/backends/pacman/groups.list	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/groups.list	2010-04-06 02:44:38.707714717 +1200
@@ -0,0 +1,65 @@
+adesklet-desklets	desktop-other
+base			system
+base-devel		programming
+bmp-io-plugins		multimedia
+bmp-plugins		multimedia
+cegcc			programming
+compiz			desktop-other
+compiz-fusion		desktop-other
+compiz-fusion-gtk	desktop-gnome
+compiz-fusion-kde	desktop-kde
+compiz-gnome		desktop-gnome
+compiz-gtk		desktop-gnome
+compiz-kde		desktop-kde
+e17-extra-svn		desktop-other
+e17-libs-svn		desktop-other
+e17-svn			desktop-other
+fprint			other
+gimp-help		other
+gimp-plugins		other
+gnome			desktop-gnome
+gnome-extra		desktop-gnome
+gnustep-core		desktop-other
+google-gadgets		desktop-other
+gstreamer0.10-plugins	multimedia
+kde			desktop-kde
+kdeaccessibility	desktop-kde
+kdeadmin		desktop-kde
+kdeartwork		desktop-kde
+kdebase			desktop-kde
+kdeedu			desktop-kde
+kde-extragear		desktop-kde
+kdegames		desktop-kde
+kdegraphics		desktop-kde
+kde-l10n		desktop-kde
+kde-meta		desktop-kde
+kdemultimedia		desktop-kde
+kdenetwork		desktop-kde
+kdepim			desktop-kde
+kdeplasma-addons	desktop-kde
+kdesdk			desktop-kde
+kdetoys			desktop-kde
+kdeutils		desktop-kde
+kdewebdev		desktop-kde
+koffice			desktop-kde
+ladspa-plugins		multimedia
+lib32			other
+lxde			other
+qtcurve			desktop-kde
+rox-desktop		desktop-other
+telepathy		other
+texlive-lang		other
+texlive-lang-doc	other
+texlive-most		other
+texlive-most-doc	other
+thunderbird-i18n	other
+thunderbird-spell-i18n	other
+vim-plugins		other
+xfce4			desktop-xfce
+xfce4-goodies		desktop-xfce
+xmms-effect-plugins	multimedia
+xmms-io-plugins		multimedia
+xmms-plugins		multimedia
+xorg			desktop-other
+xorg-input-drivers	desktop-other
+xorg-video-drivers	desktop-other
diff -Nru a/backends/pacman/Makefile.am b/backends/pacman/Makefile.am
--- a/backends/pacman/Makefile.am	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/Makefile.am	2010-04-12 15:08:01.377101409 +1200
@@ -0,0 +1,48 @@
+PACMAN_CONFIG_FILE = $(confdir)/pacman.conf
+PACMAN_GROUP_LIST = $(confdir)/groups.list
+PACMAN_REPO_LIST = $(confdir)/repos.list
+PACMAN_REPO_LIST_HEADER = "\# Generated by $(PACKAGE_NAME) - DO NOT MODIFY"
+PACMAN_CACHE_PATH = "/var/lib/pacman"
+PACMAN_DEFAULT_PATH = "/bin:/usr/bin:/sbin:/usr/sbin"
+PACMAN_PACKAGE_URL = "http://www.archlinux.org/packages/%s/%s/%s/"
+
+DEFS = -DPACMAN_CONFIG_FILE=\"$(PACMAN_CONFIG_FILE)\" \
+       -DPACMAN_GROUP_LIST=\"$(PACMAN_GROUP_LIST)\" \
+       -DPACMAN_REPO_LIST=\"$(PACMAN_REPO_LIST)\" \
+       -DPACMAN_REPO_LIST_HEADER=\"$(PACMAN_REPO_LIST_HEADER)\" \
+       -DPACMAN_CACHE_PATH=\"$(PACMAN_CACHE_PATH)\" \
+       -DPACMAN_DEFAULT_PATH=\"$(PACMAN_DEFAULT_PATH)\" \
+       -DPACMAN_PACKAGE_URL=\"$(PACMAN_PACKAGE_URL)\"
+
+confdir = $(PK_CONF_DIR)/pacman.d
+conf_DATA = groups.list \
+            pacman.conf \
+            repos.list
+
+plugindir = $(PK_PLUGIN_DIR)
+plugin_LTLIBRARIES = libpk_backend_pacman.la
+
+libpk_backend_pacman_la_SOURCES = backend-depends.c \
+                                  backend-error.c \
+                                  backend-groups.c \
+                                  backend-install.c \
+                                  backend-packages.c \
+                                  backend-pacman.c \
+                                  backend-remove.c \
+                                  backend-repos.c \
+                                  backend-search.c \
+                                  backend-transaction.c \
+                                  backend-update.c
+
+libpk_backend_pacman_la_LIBADD = $(PK_PLUGIN_LIBS) \
+                                 $(PACMAN_LIBS)
+libpk_backend_pacman_la_LDFLAGS = -module -avoid-version
+libpk_backend_pacman_la_CFLAGS = $(PK_PLUGIN_CFLAGS) \
+                                 $(PACMAN_CFLAGS) \
+                                 $(WARNINGFLAGS_C)
+repos.list:
+	echo $(PACMAN_REPO_LIST_HEADER) > $@
+
+BUILT_SOURCES = repos.list
+
+EXTRA_DIST = $(conf_DATA)
diff -Nru a/backends/pacman/pacman.conf b/backends/pacman/pacman.conf
--- a/backends/pacman/pacman.conf	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/pacman.conf	2010-04-06 02:44:38.714383444 +1200
@@ -0,0 +1,12 @@
+# PackageKit configuration for the pacman backend
+# See the pacman.conf(5) manpage for option and repository directives.
+
+[options]
+
+# Use default pacman configuration initially
+#
+Include = /etc/pacman.conf
+
+# Prevent PackageKit from removing itself
+#
+HoldPkg = packagekit
diff -Nru a/configure.ac b/configure.ac
--- a/configure.ac	2010-03-30 00:53:57.000000000 +1300
+++ b/configure.ac	2010-04-06 02:44:38.714383444 +1200
@@ -502,6 +502,7 @@
 AC_ARG_ENABLE(dummy, AS_HELP_STRING([--enable-dummy],[use the dummy backend]),enable_dummy=$enableval,enable_dummy=yes)
 AC_ARG_ENABLE(entropy, AS_HELP_STRING([--enable-entropy],[use the entropy backend]),enable_entropy=$enableval,enable_entropy=no)
 AC_ARG_ENABLE(opkg, AS_HELP_STRING([--enable-opkg],[use the OPKG backend]),enable_opkg=$enableval,enable_opkg=no)
+AC_ARG_ENABLE(pacman, AS_HELP_STRING([--enable-pacman],[use the PACMAN backend]),enable_pacman=$enableval,enable_pacman=no)
 AC_ARG_ENABLE(pisi, AS_HELP_STRING([--enable-pisi],[use the PiSi backend]),enable_pisi=$enableval,enable_pisi=no)
 AC_ARG_ENABLE(poldek, AS_HELP_STRING([--enable-poldek],[use the poldek backend]),enable_poldek=$enableval,enable_poldek=no)
 AC_ARG_ENABLE(portage, AS_HELP_STRING([--enable-portage],[use the portage backend]),enable_portage=$enableval,enable_portage=no)
@@ -522,6 +523,7 @@
 AM_CONDITIONAL(BACKEND_TYPE_DUMMY, [test x$enable_dummy = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_ENTROPY, [test x$enable_entropy = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_OPKG, [test x$enable_opkg = xyes])
+AM_CONDITIONAL(BACKEND_TYPE_PACMAN, [test x$enable_pacman = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_PISI, [test x$enable_pisi = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_POLDEK, [test x$enable_poldek = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_PORTAGE, [test x$enable_portage = xyes])
@@ -608,6 +610,8 @@
 		with_default_backend=slapt
 	elif test -f /usr/bin/smart ; then
 		with_default_backend=smart
+	elif test -f /usr/lib/libpacman-glib.so ; then
+		with_default_backend=pacman
 	elif test -f /usr/bin/pisi ; then
 		with_default_backend=pisi
 	elif test -f /usr/bin/razor ; then
@@ -732,6 +736,12 @@
 			[AC_MSG_WARN([No alpm headers found - falling back to dummy backend])])
 fi
 
+if test x$enable_pacman = xyes; then
+	PKG_CHECK_MODULES(PACMAN, pacman-glib >= 3.3.0)
+	AC_SUBST(PACMAN_CFLAGS)
+	AC_SUBST(PACMAN_LIBS)
+fi
+
 if test x$enable_poldek = xyes; then
 	POLDEK_CFLAGS="-I/usr/include/poldek"
 	POLDEK_LIBS="-lpoclidek -lpoldek"
@@ -820,6 +830,7 @@
 backends/urpmi/helpers/urpmi_backend/Makefile
 backends/razor/Makefile
 backends/yum/Makefile
+backends/pacman/Makefile
 backends/pisi/Makefile
 backends/poldek/Makefile
 backends/portage/Makefile
@@ -886,6 +897,7 @@
         Entropy backend:           ${enable_entropy}
         OPKG backend:              ${enable_opkg}
         Razor backend:             ${enable_razor}
+        PACMAN backend:            ${enable_pacman}
         PiSi backend:              ${enable_pisi}
         poldek backend:            ${enable_poldek}
         Portage backend:           ${enable_portage}
