diff -Nru a/backends/Makefile.am b/backends/Makefile.am
--- a/backends/Makefile.am	2010-02-16 06:58:07.000000000 +1300
+++ b/backends/Makefile.am	2010-03-21 10:23:23.344296313 +1300
@@ -32,6 +32,10 @@
 SUBDIRS += opkg
 endif
 
+if BACKEND_TYPE_PACMAN
+SUBDIRS += pacman
+endif
+
 if BACKEND_TYPE_RAZOR
 SUBDIRS += razor
 endif
diff -Nru a/backends/pacman/backend-depends.c b/backends/pacman/backend-depends.c
--- a/backends/pacman/backend-depends.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-depends.c	2010-04-05 23:51:21.470230606 +1200
@@ -0,0 +1,288 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-packages.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+#include "backend-depends.h"
+
+static PacmanPackage *
+pacman_list_find_provider (const PacmanList *packages, PacmanDependency *depend)
+{
+	const PacmanList *list;
+
+	g_return_val_if_fail (depend != NULL, NULL);
+
+	/* find a package that provides depend */
+	for (list = packages; list != NULL; list = pacman_list_next (list)) {
+		PacmanPackage *provider = (PacmanPackage *) pacman_list_get (list);
+
+		if (pacman_dependency_satisfied_by (depend, provider)) {
+			return provider;
+		}
+	}
+
+	return NULL;
+}
+
+static PacmanPackage *
+pacman_sync_databases_find_provider (PacmanDependency *depend)
+{
+	const PacmanList *databases;
+
+	g_return_val_if_fail (pacman != NULL, NULL);
+	g_return_val_if_fail (depend != NULL, NULL);
+
+	/* find the default package that provides depend */
+	for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+		PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+		PacmanPackage *provider = pacman_database_find_package (database, pacman_dependency_get_name (depend));
+
+		if (provider != NULL && pacman_dependency_satisfied_by (depend, provider)) {
+			return provider;
+		}
+	}
+
+	/* find any package that provides depend */
+	for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+		PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+		PacmanPackage *provider = pacman_list_find_provider (pacman_database_get_packages (database), depend);
+
+		if (provider != NULL) {
+			return provider;
+		}
+	}
+
+	return NULL;
+}
+
+static gboolean
+backend_get_depends_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list, *packages = NULL;
+
+	PkBitfield filters;
+	gchar **package_ids;
+	gboolean recursive;
+
+	gboolean search_installed;
+	gboolean search_not_installed;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	filters = pk_backend_get_uint (backend, "filters");
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	recursive = pk_backend_get_bool (backend, "recursive");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	search_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_INSTALLED);
+	search_not_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_NOT_INSTALLED);
+
+	/* construct an initial package list */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+
+		if (package == NULL) {
+			pacman_list_free (packages);
+			pk_backend_finished (backend);
+			return FALSE;
+		}
+
+		packages = pacman_list_add (packages, package);
+	}
+
+	/* package list might be modified along the way but that is ok */
+	for (list = packages; list != NULL; list = pacman_list_next (list)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (list);
+		const PacmanList *depends;
+
+		for (depends = pacman_package_get_dependencies (package); depends != NULL; depends = pacman_list_next (depends)) {
+			PacmanDependency *depend = (PacmanDependency *) pacman_list_get (depends);
+			PacmanPackage *provider = pacman_list_find_provider (packages, depend);
+
+			/* dependency is already satisfied */
+			if (provider != NULL) {
+				continue;
+			}
+
+			/* look for installed dependencies */
+			provider = pacman_list_find_provider (pacman_database_get_packages (local_database), depend);
+			if (provider != NULL) {
+				/* don't emit when not needed... */
+				if (!search_not_installed) {
+					backend_package (backend, provider, PK_INFO_ENUM_INSTALLED);
+					/* ... and assume installed packages also have installed dependencies */
+					if (recursive) {
+						packages = pacman_list_add (packages, provider);
+					}
+				}
+				continue;
+			}
+
+			/* look for non-installed dependencies */
+			provider = pacman_sync_databases_find_provider (depend);
+			if (provider != NULL) {
+				/* don't emit when not needed... */
+				if (!search_installed) {
+					backend_package (backend, provider, PK_INFO_ENUM_AVAILABLE);
+				}
+				/* ... but keep looking for installed dependencies */
+				if (recursive) {
+					packages = pacman_list_add (packages, provider);
+				}
+			} else {
+				gchar *depend_id = pacman_dependency_to_string (depend);
+				pk_backend_error_code (backend, PK_ERROR_ENUM_DEP_RESOLUTION_FAILED, "Could not resolve dependency %s", depend_id);
+				g_free (depend_id);
+
+				pacman_list_free (packages);
+				pk_backend_finished (backend);
+				return FALSE;
+			}
+		}
+	}
+
+	pacman_list_free (packages);
+	pk_backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_depends:
+ **/
+void
+backend_get_depends (PkBackend *backend, PkBitfield filters, gchar **package_ids, gboolean recursive)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+
+	pk_backend_thread_create (backend, backend_get_depends_thread);
+}
+
+static PacmanPackage *
+pacman_list_find_package (const PacmanList *packages, const gchar *name)
+{
+	const PacmanList *list;
+
+	g_return_val_if_fail (name != NULL, NULL);
+
+	/* find a package called name */
+	for (list = packages; list != NULL; list = pacman_list_next (list)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (list);
+
+		if (g_strcmp0 (name, pacman_package_get_name (package)) == 0) {
+			return package;
+		}
+	}
+
+	return NULL;
+}
+
+static gboolean
+backend_get_requires_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list, *packages = NULL;
+
+	gchar **package_ids;
+	gboolean recursive;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	recursive = pk_backend_get_bool (backend, "recursive");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* construct an initial package list */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+
+		if (package == NULL) {
+			pacman_list_free (packages);
+			pk_backend_finished (backend);
+			return FALSE;
+		}
+
+		packages = pacman_list_add (packages, package);
+	}
+
+	/* package list might be modified along the way but that is ok */
+	for (list = packages; list != NULL; list = pacman_list_next (list)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (list);
+		PacmanList *requires, *required_by = pacman_package_find_required_by (package);
+
+		for (requires = required_by; requires != NULL; requires = pacman_list_next (requires)) {
+			const gchar *name = (const gchar *) pacman_list_get (requires);
+			PacmanPackage *requirer = pacman_list_find_package (packages, name);
+
+			/* requirer has already been handled */
+			if (requirer != NULL) {
+				continue;
+			}
+
+			/* look for installed requirers */
+			requirer = pacman_database_find_package (local_database, name);
+			if (requirer == NULL) {
+				pk_backend_error_code (backend, PK_ERROR_ENUM_PACKAGE_NOT_FOUND, "Could not find package %s", name);
+
+				pacman_list_free_full (required_by, g_free);
+				pacman_list_free (packages);
+				pk_backend_finished (backend);
+				return FALSE;
+			}
+
+			backend_package (backend, requirer, PK_INFO_ENUM_INSTALLED);
+			if (recursive) {
+				packages = pacman_list_add (packages, requirer);
+			}
+		}
+
+		pacman_list_free_full (required_by, g_free);
+	}
+
+	pacman_list_free (packages);
+	pk_backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_requires:
+ **/
+void
+backend_get_requires (PkBackend *backend, PkBitfield filters, gchar **package_ids, gboolean recursive)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+
+	pk_backend_thread_create (backend, backend_get_requires_thread);
+}
diff -Nru a/backends/pacman/backend-depends.h b/backends/pacman/backend-depends.h
--- a/backends/pacman/backend-depends.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-depends.h	2010-03-21 10:23:23.347629140 +1300
@@ -0,0 +1,33 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_get_depends	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**package_ids,
+				 gboolean	 recursive);
+void	 backend_get_requires	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**package_ids,
+				 gboolean	 recursive);
diff -Nru a/backends/pacman/backend-error.c b/backends/pacman/backend-error.c
--- a/backends/pacman/backend-error.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-error.c	2010-04-01 01:03:32.900131104 +1300
@@ -0,0 +1,185 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-error.h"
+
+void
+backend_error (PkBackend *backend, GError *error)
+{
+	PkErrorEnum code = PK_ERROR_ENUM_INTERNAL_ERROR;
+
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (error != NULL);
+
+	/* convert error codes */
+	if (error->domain == PACMAN_ERROR) {
+		switch (error->code) {
+			case PACMAN_ERROR_MEMORY:
+				code = PK_ERROR_ENUM_OOM;
+				break;
+
+			case PACMAN_ERROR_SYSTEM:
+			case PACMAN_ERROR_INVALID_ARGS:
+			case PACMAN_ERROR_NOT_INITIALIZED:
+			case PACMAN_ERROR_DATABASE_NOT_INITIALIZED:
+			case PACMAN_ERROR_SERVER_INVALID_URL:
+			case PACMAN_ERROR_REGEX_INVALID:
+			case PACMAN_ERROR_LIBARCHIVE:
+			case PACMAN_ERROR_LIBFETCH:
+			case PACMAN_ERROR_DOWNLOAD_HANDLER:
+				code = PK_ERROR_ENUM_INTERNAL_ERROR;
+				break;
+
+			case PACMAN_ERROR_NOT_PERMITTED:
+				code = PK_ERROR_ENUM_NOT_AUTHORIZED;
+				break;
+
+			case PACMAN_ERROR_FILE_NOT_FOUND:
+			case PACMAN_ERROR_DIRECTORY_NOT_FOUND:
+				code = PK_ERROR_ENUM_FILE_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_ALREADY_INITIALIZED:
+			case PACMAN_ERROR_DATABASE_ALREADY_INITIALIZED:
+				code = PK_ERROR_ENUM_FAILED_INITIALIZATION;
+				break;
+
+			case PACMAN_ERROR_ALREADY_RUNNING:
+				code = PK_ERROR_ENUM_CANNOT_GET_LOCK;
+				break;
+
+			case PACMAN_ERROR_DATABASE_OPEN_FAILED:
+				code = PK_ERROR_ENUM_REPO_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_DATABASE_CREATE_FAILED:
+				code = PK_ERROR_ENUM_CANNOT_WRITE_REPO_CONFIG;
+				break;
+
+			case PACMAN_ERROR_DATABASE_NOT_FOUND:
+				code = PK_ERROR_ENUM_REPO_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_DATABASE_UPDATE_FAILED:
+				code = PK_ERROR_ENUM_REPO_NOT_AVAILABLE;
+				break;
+
+			case PACMAN_ERROR_DATABASE_REMOVE_FAILED:
+				code = PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR;
+				break;
+
+			case PACMAN_ERROR_SERVER_NONE_AVAILABLE:
+				code = PK_ERROR_ENUM_NO_MORE_MIRRORS_TO_TRY;
+				break;
+
+			case PACMAN_ERROR_TRANSACTION_ALREADY_INITIALIZED:
+			case PACMAN_ERROR_TRANSACTION_NOT_INITIALIZED:
+			case PACMAN_ERROR_TRANSACTION_DUPLICATE_TARGET:
+			case PACMAN_ERROR_TRANSACTION_NOT_READY:
+			case PACMAN_ERROR_TRANSACTION_NOT_PREPARED:
+			case PACMAN_ERROR_TRANSACTION_INVALID_OPERATION:
+			case PACMAN_ERROR_TRANSACTION_NOT_LOCKED:
+				code = PK_ERROR_ENUM_TRANSACTION_ERROR;
+				break;
+
+			case PACMAN_ERROR_TRANSACTION_ABORTED:
+				code = PK_ERROR_ENUM_TRANSACTION_CANCELLED;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_NOT_FOUND:
+				code = PK_ERROR_ENUM_PACKAGE_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_IGNORED:
+				code = PK_ERROR_ENUM_PACKAGE_INSTALL_BLOCKED;
+				break;
+
+			case PACMAN_ERROR_DELTA_INVALID:
+			case PACMAN_ERROR_PACKAGE_INVALID:
+				code = PK_ERROR_ENUM_INVALID_PACKAGE_FILE;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_OPEN_FAILED:
+				code = PK_ERROR_ENUM_PACKAGE_NOT_FOUND;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_REMOVE_FAILED:
+				code = PK_ERROR_ENUM_PACKAGE_FAILED_TO_REMOVE;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_UNKNOWN_FILENAME:
+			case PACMAN_ERROR_PACKAGE_DATABASE_NOT_FOUND:
+				code = PK_ERROR_ENUM_PACKAGE_FAILED_TO_CONFIGURE;
+				break;
+
+			case PACMAN_ERROR_DELTA_PATCH_FAILED:
+				code = PK_ERROR_ENUM_PACKAGE_FAILED_TO_BUILD;
+				break;
+
+			case PACMAN_ERROR_DEPENDENCY_UNSATISFIED:
+				code = PK_ERROR_ENUM_DEP_RESOLUTION_FAILED;
+				break;
+
+			case PACMAN_ERROR_CONFLICT:
+				code = PK_ERROR_ENUM_PACKAGE_CONFLICTS;
+				break;
+
+			case PACMAN_ERROR_FILE_CONFLICT:
+				code = PK_ERROR_ENUM_FILE_CONFLICTS;
+				break;
+
+			case PACMAN_ERROR_DOWNLOAD_FAILED:
+				code = PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED;
+				break;
+
+			case PACMAN_ERROR_CONFIG_INVALID:
+				code = PK_ERROR_ENUM_FAILED_CONFIG_PARSING;
+				break;
+
+			case PACMAN_ERROR_PACKAGE_HELD:
+				code = PK_ERROR_ENUM_CANNOT_REMOVE_SYSTEM_PACKAGE;
+				break;
+		}
+	}
+
+	pk_backend_error_code (backend, code, "%s", error->message);
+	g_error_free (error);
+}
+
+void
+backend_message (PkBackend *backend, const gchar *message)
+{
+	guint iterator;
+	gchar **messages = g_strsplit_set (message, "\r\n", 0);
+
+	/* display multi-line messages in a nice format */
+	for (iterator = 0; messages[iterator] != NULL; ++iterator) {
+		g_strstrip (messages[iterator]);
+		if (*messages[iterator] != '\0') {
+			pk_backend_message (backend, PK_MESSAGE_ENUM_UNKNOWN, "%s", messages[iterator]);
+		}
+	}
+
+	g_strfreev (messages);
+}
diff -Nru a/backends/pacman/backend-error.h b/backends/pacman/backend-error.h
--- a/backends/pacman/backend-error.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-error.h	2010-03-21 10:23:23.347629140 +1300
@@ -0,0 +1,29 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_error		(PkBackend	*backend,
+				 GError		*error);
+void	 backend_message	(PkBackend	*backend,
+				 const gchar	*message);
diff -Nru a/backends/pacman/backend-groups.c b/backends/pacman/backend-groups.c
--- a/backends/pacman/backend-groups.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-groups.c	2010-03-30 23:32:39.549353214 +1300
@@ -0,0 +1,152 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <string.h>
+#include <gio/gio.h>
+#include "backend-error.h"
+#include "backend-groups.h"
+
+static GHashTable *group_map = NULL;
+static PkBitfield groups = 0;
+
+static gboolean
+groups_load (GError **error)
+{
+	GFile *file;
+	GFileInputStream *file_stream;
+	GDataInputStream *data_stream;
+
+	gchar *key, *value;
+	GError *e = NULL;
+
+	g_return_val_if_fail (group_map != NULL, FALSE);
+
+	egg_debug ("pacman: reading groups from %s", PACMAN_GROUP_LIST);
+	file = g_file_new_for_path (PACMAN_GROUP_LIST);
+	file_stream = g_file_read (file, NULL, &e);
+
+	if (file_stream == NULL) {
+		g_object_unref (file);
+		g_propagate_error (error, e);
+		return FALSE;
+	}
+
+	/* read groups line by line, ignoring comments */
+	data_stream = g_data_input_stream_new (G_INPUT_STREAM (file_stream));
+	while ((value = g_data_input_stream_read_line (data_stream, NULL, NULL, &e)) != NULL) {
+		PkGroupEnum group;
+
+		g_strstrip (value);
+		if (*value == '\0' || *value == '#') {
+			g_free (value);
+			continue;
+		}
+
+		/* line format: alpm-group (space|tab)+ packagekit-group */
+		key = strsep (&value, " 	");
+		g_strchomp (key);
+
+		if (value == NULL) {
+			/* safe to cast as it is never freed or modified */
+			value = (gchar *) "other";
+			group = PK_GROUP_ENUM_OTHER;
+		} else {
+			g_strchug (value);
+			group = pk_group_enum_from_string (value);
+		}
+
+		if (group != PK_GROUP_ENUM_UNKNOWN) {
+			/* use replace because key and value are allocated together */
+			g_hash_table_replace (group_map, key, value);
+			pk_bitfield_add (groups, group);
+		}
+	}
+
+	g_object_unref (data_stream);
+	g_object_unref (file_stream);
+	g_object_unref (file);
+
+	if (e != NULL) {
+		g_propagate_error (error, e);
+		return FALSE;
+	} else {
+		return TRUE;
+	}
+}
+
+gboolean
+backend_initialize_groups (PkBackend *backend)
+{
+	GError *error = NULL;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	group_map = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+
+	if (!groups_load (&error)) {
+		backend_error (backend, error);
+		return FALSE;
+	} else {
+		return TRUE;
+	}
+}
+
+gboolean
+backend_destroy_groups (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	if (group_map != NULL) {
+		g_hash_table_unref (group_map);
+	}
+	return TRUE;
+}
+
+const gchar *
+pacman_package_get_group (PacmanPackage *package)
+{
+	const PacmanList *list;
+
+	g_return_val_if_fail (group_map != NULL, NULL);
+	g_return_val_if_fail (package != NULL, NULL);
+
+	/* use the first group that we recognise */
+	for (list = pacman_package_get_groups (package); list != NULL; list = pacman_list_next (list)) {
+		gpointer value = g_hash_table_lookup (group_map, pacman_list_get (list));
+		if (value != NULL) {
+			return (const gchar *) value;
+		}
+	}
+
+	return "other";
+}
+
+/**
+ * backend_get_groups:
+ **/
+PkBitfield backend_get_groups (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, 0);
+
+	return groups;
+}
diff -Nru a/backends/pacman/backend-groups.h b/backends/pacman/backend-groups.h
--- a/backends/pacman/backend-groups.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-groups.h	2010-03-21 10:23:23.350965319 +1300
@@ -0,0 +1,31 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <pk-backend.h>
+
+gboolean	 backend_initialize_groups	(PkBackend	*backend);
+gboolean	 backend_destroy_groups		(PkBackend	*backend);
+
+const gchar	*pacman_package_get_group	(PacmanPackage	*package);
+PkBitfield	 backend_get_groups		(PkBackend	*backend);
diff -Nru a/backends/pacman/backend-install.c b/backends/pacman/backend-install.c
--- a/backends/pacman/backend-install.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-install.c	2010-04-05 23:40:15.536960065 +1200
@@ -0,0 +1,179 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-error.h"
+#include "backend-pacman.h"
+#include "backend-transaction.h"
+#include "backend-install.h"
+
+static gboolean
+backend_download_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+	PacmanList *cache_paths;
+
+	gchar **package_ids;
+	const gchar *directory;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_IGNORE_DEPENDENCIES | PACMAN_TRANSACTION_FLAGS_IGNORE_DEPENDENCY_CONFLICTS | PACMAN_TRANSACTION_FLAGS_SYNC_DOWNLOAD_ONLY;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	directory = pk_backend_get_string (backend, "directory");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+	g_return_val_if_fail (directory != NULL, FALSE);
+
+	/* download files to a PackageKit directory */
+	cache_paths = pacman_list_strdup (pacman_manager_get_cache_paths (pacman));
+	pacman_manager_set_cache_paths (pacman, NULL);
+	pacman_manager_add_cache_path (pacman, directory);
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup_printf ("%s/%s", package_id_data[PK_PACKAGE_ID_DATA], package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TYPE_SYNC, flags, list);
+		pacman_list_free_full (list, g_free);
+	}
+
+	pacman_manager_set_cache_paths (pacman, cache_paths);
+	pacman_list_free_full (cache_paths, g_free);
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_download_packages:
+ **/
+void
+backend_download_packages (PkBackend *backend, gchar **package_ids, const gchar *directory)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+	g_return_if_fail (directory != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_SETUP);
+	pk_backend_thread_create (backend, backend_download_packages_thread);
+}
+
+static gboolean
+backend_install_files_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	/* TODO: use only_trusted once pacman implements package signing */
+	gchar **full_paths;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	full_paths = pk_backend_get_strv (backend, "full_paths");
+
+	g_return_val_if_fail (full_paths != NULL, FALSE);
+
+	/* collect targets for the transaction */
+	for (iterator = 0; full_paths[iterator] != NULL; ++iterator) {
+		list = pacman_list_add (list, full_paths[iterator]);
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TYPE_INSTALL, flags, list);
+		pacman_list_free (list);
+	}
+
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_install_files:
+ **/
+void
+backend_install_files (PkBackend *backend, gboolean only_trusted, gchar	**full_paths)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (full_paths != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_SETUP);
+	pk_backend_thread_create (backend, backend_install_files_thread);
+}
+
+static gboolean
+backend_install_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	/* TODO: use only_trusted once pacman implements package signing */
+	gchar **package_ids;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup_printf ("%s/%s", package_id_data[PK_PACKAGE_ID_DATA], package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TYPE_SYNC, flags, list);
+		pacman_list_free_full (list, g_free);
+	}
+
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_install_packages:
+ **/
+void
+backend_install_packages (PkBackend *backend, gboolean only_trusted, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_SETUP);
+	pk_backend_thread_create (backend, backend_install_packages_thread);
+}
diff -Nru a/backends/pacman/backend-install.h b/backends/pacman/backend-install.h
--- a/backends/pacman/backend-install.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-install.h	2010-04-05 22:34:07.404027204 +1200
@@ -0,0 +1,34 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_download_packages	(PkBackend	*backend,
+					 gchar		**package_ids,
+					 const gchar	*directory);
+void	 backend_install_files		(PkBackend	*backend,
+					 gboolean	 only_trusted,
+					 gchar		**full_paths);
+void	 backend_install_packages	(PkBackend	*backend,
+					 gboolean	 only_trusted,
+					 gchar		**package_ids);
diff -Nru a/backends/pacman/backend-packages.c b/backends/pacman/backend-packages.c
--- a/backends/pacman/backend-packages.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-packages.c	2010-04-05 22:36:15.047347139 +1200
@@ -0,0 +1,318 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-groups.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+#include "backend-packages.h"
+
+gchar *
+pacman_package_make_id (PacmanPackage *package)
+{
+	const gchar *name, *version, *arch, *repo;
+	PacmanDatabase *database;
+
+	g_return_val_if_fail (local_database != NULL, NULL);
+	g_return_val_if_fail (package != NULL, NULL);
+
+	name = pacman_package_get_name (package);
+	version = pacman_package_get_version (package);
+
+	arch = pacman_package_get_arch (package);
+	if (arch == NULL) {
+		arch = "any";
+	}
+
+	/* PackageKit requires "local" for package files and "installed" for installed packages */
+	database = pacman_package_get_database (package);
+	if (database == NULL) {
+		repo = "local";
+	} else if (database == local_database) {
+		repo = "installed";
+	} else {
+		repo = pacman_database_get_name (database);
+	}
+
+	return pk_package_id_build (name, version, arch, repo);
+}
+
+void
+backend_package (PkBackend *backend, PacmanPackage *package, PkInfoEnum info)
+{
+	gchar *package_id;
+
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package != NULL);
+
+	/* build and emit package id */
+	package_id = pacman_package_make_id (package);
+	pk_backend_package (backend, info, package_id, pacman_package_get_description (package));
+	g_free (package_id);
+}
+
+PacmanPackage *
+backend_get_package (PkBackend *backend, const gchar *package_id)
+{
+	gchar **package_id_data;
+	const gchar *repo;
+	PacmanDatabase *database;
+	PacmanPackage *package;
+
+	g_return_val_if_fail (pacman != NULL, NULL);
+	g_return_val_if_fail (local_database != NULL, NULL);
+	g_return_val_if_fail (backend != NULL, NULL);
+	g_return_val_if_fail (package_id != NULL, NULL);
+
+	package_id_data = pk_package_id_split (package_id);
+	repo = package_id_data[PK_PACKAGE_ID_DATA];
+
+	/* find the database to search in */
+	if (g_strcmp0 (repo, "installed") == 0) {
+		database = local_database;
+	} else {
+		const PacmanList *databases;
+
+		for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+			database = (PacmanDatabase *) pacman_list_get (databases);
+
+			if (g_strcmp0 (pacman_database_get_name (database), repo) == 0) {
+				break;
+			}
+		}
+
+		/* no database called repo was found */
+		if (databases == NULL) {
+			pk_backend_error_code (backend, PK_ERROR_ENUM_REPO_NOT_FOUND, "Could not find repo [%s]", repo);
+
+			g_strfreev (package_id_data);
+			return NULL;
+		}
+	}
+
+	/* find the package in the database */
+	package = pacman_database_find_package (database, package_id_data[PK_PACKAGE_ID_NAME]);
+	if (package == NULL || g_strcmp0 (pacman_package_get_version (package), package_id_data[PK_PACKAGE_ID_VERSION]) != 0) {
+		pk_backend_error_code (backend, PK_ERROR_ENUM_PACKAGE_ID_INVALID, "Could not find package with ID %s", package_id);
+
+		g_strfreev (package_id_data);
+		return NULL;
+	}
+
+	g_strfreev (package_id_data);
+	return package;
+}
+
+static gboolean
+backend_resolve_thread (PkBackend *backend)
+{
+	guint iterator;
+
+	gchar **package_ids;
+	PkBitfield filters;
+
+	gboolean search_installed;
+	gboolean search_not_installed;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	filters = pk_backend_get_uint (backend, "filters");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	search_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_INSTALLED);
+	search_not_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_NOT_INSTALLED);
+
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		/* find a package with the given id or name */
+		if (pk_package_id_check (package_ids[iterator])) {
+			PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+			if (package == NULL) {
+				pk_backend_finished (backend);
+				return FALSE;
+			}
+
+			/* don't emit when not needed */
+			if (pacman_package_get_database (package) == local_database) {
+				if (!search_not_installed) {
+					backend_package (backend, package, PK_INFO_ENUM_INSTALLED);
+				}
+			} else {
+				if (!search_installed) {
+					backend_package (backend, package, PK_INFO_ENUM_AVAILABLE);
+				}
+			}
+		} else {
+			/* find installed packages first */
+			if (!search_not_installed) {
+				PacmanPackage *package = pacman_database_find_package (local_database, package_ids[iterator]);
+
+				if (package != NULL) {
+					backend_package (backend, package, PK_INFO_ENUM_INSTALLED);
+					continue;
+				}
+			}
+
+			if (!search_installed) {
+				const PacmanList *databases;
+
+				for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+					PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+					PacmanPackage *package = pacman_database_find_package (database, package_ids[iterator]);
+
+					if (package != NULL) {
+						backend_package (backend, package, PK_INFO_ENUM_AVAILABLE);
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	pk_backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_resolve:
+ **/
+void
+backend_resolve (PkBackend *backend, PkBitfield filters, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+
+	pk_backend_thread_create (backend, backend_resolve_thread);
+}
+
+/**
+ * backend_get_details:
+ **/
+void
+backend_get_details (PkBackend *backend, gchar **package_ids)
+{
+	guint iterator;
+
+	g_return_if_fail (local_database != NULL);
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+
+	/* collect details about packages */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		const PacmanList *list;
+		GString *string;
+
+		gchar *licenses;
+		PkGroupEnum group;
+		const gchar *description, *url;
+		gulong size;
+
+		PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+		if (package == NULL) {
+			pk_backend_finished (backend);
+			return;
+		}
+
+		list = pacman_package_get_licenses (package);
+		if (list == NULL) {
+			string = g_string_new ("unknown");
+		} else {
+			string = g_string_new ((const gchar *) pacman_list_get (list));
+			for (list = pacman_list_next (list); list != NULL; list = pacman_list_next (list)) {
+				/* assume OR although it may not be correct */
+				g_string_append_printf (string, " or %s", (const gchar *) pacman_list_get (list));
+			}
+		}	
+
+		group = pk_group_enum_from_string (pacman_package_get_group (package));
+		description = pacman_package_get_description (package);
+		url = pacman_package_get_url (package);
+
+		if (pacman_package_get_database (package) == local_database) {
+			size = pacman_package_get_installed_size (package);
+		} else {
+			/* TODO: change to download_size when FS#18769 is fixed */
+			size = pacman_package_get_size (package);
+		}
+
+		licenses = g_string_free (string, FALSE);
+		pk_backend_details (backend, package_ids[iterator], licenses, group, description, url, size);
+		g_free (licenses);
+	}
+
+	pk_backend_finished (backend);
+}
+
+/**
+ * backend_get_files:
+ **/
+void
+backend_get_files (PkBackend *backend, gchar **package_ids)
+{
+	guint iterator;
+
+	g_return_if_fail (pacman != NULL);
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+
+	/* enumerate files provided by package */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		const PacmanList *list;
+		GString *string;
+		gchar *files;
+
+		PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+		if (package == NULL) {
+			pk_backend_finished (backend);
+			return;
+		}
+
+		list = pacman_package_get_files (package);
+		if (list == NULL) {
+			string = g_string_new ("");
+		} else {
+			const gchar *root_path = pacman_manager_get_root_path (pacman);
+			string = g_string_new (root_path);
+			g_string_append (string, (const gchar *) pacman_list_get (list));
+
+			for (list = pacman_list_next (list); list != NULL; list = pacman_list_next (list)) {
+				g_string_append_printf (string, ";%s%s", root_path, (const gchar *) pacman_list_get (list));
+			}
+		}	
+
+		files = g_string_free (string, FALSE);
+		pk_backend_files (backend, package_ids[iterator], files);
+		g_free (files);
+	}
+
+	pk_backend_finished (backend);
+}
diff -Nru a/backends/pacman/backend-packages.h b/backends/pacman/backend-packages.h
--- a/backends/pacman/backend-packages.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-packages.h	2010-03-21 10:23:23.350965319 +1300
@@ -0,0 +1,41 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <pk-backend.h>
+
+gchar		*pacman_package_make_id	(PacmanPackage	*package);
+void		 backend_package	(PkBackend	*backend,
+					 PacmanPackage	*package,
+					 PkInfoEnum	 info);
+
+PacmanPackage	*backend_get_package	(PkBackend	*backend,
+					 const gchar	*package_id);
+void		 backend_resolve	(PkBackend	*backend,
+					 PkBitfield	 filters,
+					 gchar		**package_ids);
+
+void		 backend_get_details	(PkBackend	*backend,
+					 gchar		**package_ids);
+void		 backend_get_files	(PkBackend	*backend,
+					 gchar		**package_ids);
diff -Nru a/backends/pacman/backend-pacman.c b/backends/pacman/backend-pacman.c
--- a/backends/pacman/backend-pacman.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-pacman.c	2010-04-05 21:48:27.330966237 +1200
@@ -0,0 +1,198 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+#include <pacman.h>
+
+#include "backend-depends.h"
+#include "backend-error.h"
+#include "backend-groups.h"
+#include "backend-install.h"
+#include "backend-packages.h"
+#include "backend-remove.h"
+#include "backend-repos.h"
+#include "backend-search.h"
+#include "backend-transaction.h"
+#include "backend-update.h"
+#include "backend-pacman.h"
+
+PacmanManager *pacman = NULL;
+
+static void
+pacman_message_cb (const gchar *domain, GLogLevelFlags level, const gchar *message, gpointer user_data)
+{
+	g_return_if_fail (message != NULL);
+	g_return_if_fail (user_data != NULL);
+
+	/* report important output to PackageKit */
+	switch (level) {
+		case G_LOG_LEVEL_WARNING:
+		case G_LOG_LEVEL_MESSAGE:
+			egg_warning ("pacman: %s", message);
+			backend_message ((PkBackend *) user_data, message);
+			break;
+
+		case G_LOG_LEVEL_INFO:
+		case G_LOG_LEVEL_DEBUG:
+			egg_debug ("pacman: %s", message);
+			break;
+
+		default:
+			break;
+	}
+}
+
+/**
+ * backend_initialize:
+ **/
+static void
+backend_initialize (PkBackend *backend)
+{
+	GError *error = NULL;
+	GLogLevelFlags flags = G_LOG_LEVEL_WARNING | G_LOG_LEVEL_MESSAGE | G_LOG_LEVEL_INFO | G_LOG_LEVEL_DEBUG;
+
+	g_return_if_fail (backend != NULL);
+
+	/* handle output from pacman */
+	g_log_set_handler ("Pacman", flags, pacman_message_cb, backend);
+
+	/* PATH needs to be set for install scriptlets */
+	g_setenv ("PATH", PACMAN_DEFAULT_PATH, FALSE);
+
+	egg_debug ("pacman: initializing");
+
+	/* initialize pacman-glib */
+	pacman = pacman_manager_get (&error);
+	if (pacman == NULL) {
+		backend_error (backend, error);
+		return;
+	}
+
+	egg_debug ("pacman: reading config from %s", PACMAN_CONFIG_FILE);
+
+	/* read configuration from pacman config file */
+	if (!pacman_manager_configure (pacman, PACMAN_CONFIG_FILE, &error)) {
+		backend_error (backend, error);
+		return;
+	}
+
+	/* disable the relevant databases */
+	if (!backend_initialize_databases (backend)) {
+		return;
+	}
+
+	/* read group translations from config file */
+	if (!backend_initialize_groups (backend)) {
+		return;
+	}
+
+	/* setup better download progress reporting */
+	if (!backend_initialize_downloads (backend)) {
+		return;
+	}
+}
+
+/**
+ * backend_destroy:
+ **/
+static void
+backend_destroy (PkBackend *backend)
+{
+	g_return_if_fail (backend != NULL);
+
+	egg_debug ("pacman: cleaning up");
+
+	backend_destroy_downloads (backend);
+	backend_destroy_groups (backend);
+	backend_destroy_databases (backend);
+
+	if (pacman != NULL) {
+		g_object_unref (pacman);
+	}
+}
+
+/**
+ * backend_get_filters:
+ **/
+static PkBitfield
+backend_get_filters (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, 0);
+
+	return pk_bitfield_from_enums (PK_FILTER_ENUM_INSTALLED, -1);
+}
+
+/**
+ * backend_get_mime_types:
+ **/
+static gchar *
+backend_get_mime_types (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, NULL);
+
+	/* packages currently use .pkg.tar.gz and .pkg.tar.xz */
+	return g_strdup ("application/x-compressed-tar;application/x-xz-compressed-tar");
+}
+
+PK_BACKEND_OPTIONS (
+	"pacman",				/* description */
+	"Jonathan Conder <j@skurvy.no-ip.org>",	/* author */
+	backend_initialize,			/* initialize */
+	backend_destroy,			/* destroy */
+	backend_get_groups,			/* get_groups */
+	backend_get_filters,			/* get_filters */
+	NULL,					/* get_roles */
+	backend_get_mime_types,			/* get_mime_types */
+	NULL,					/* cancel */
+	backend_download_packages,		/* download_packages */
+	NULL,					/* get_categories */
+	backend_get_depends,			/* get_depends */
+	backend_get_details,			/* get_details */
+	NULL,					/* get_distro_upgrades */
+	backend_get_files,			/* get_files */
+	backend_get_packages,			/* get_packages */
+	backend_get_repo_list,			/* get_repo_list */
+	backend_get_requires,			/* get_requires */
+	backend_get_update_detail,		/* get_update_detail */
+	backend_get_updates,			/* get_updates */
+	backend_install_files,			/* install_files */
+	backend_install_packages,		/* install_packages */
+	NULL,					/* install_signature */
+	backend_refresh_cache,			/* refresh_cache */
+	backend_remove_packages,		/* remove_packages */
+	backend_repo_enable,			/* repo_enable */
+	NULL,					/* repo_set_data */
+	backend_resolve,			/* resolve */
+	NULL,					/* rollback */
+	backend_search_details,			/* search_details */
+	NULL,					/* search_files */
+	backend_search_groups,			/* search_groups */
+	backend_search_names,			/* search_names */
+	backend_update_packages,		/* update_packages */
+	backend_update_system,			/* update_system */
+	backend_what_provides,			/* what_provides */
+	NULL,					/* simulate_install_files */
+	NULL,					/* simulate_install_packages */
+	backend_simulate_remove_packages,	/* simulate_remove_packages */
+	NULL					/* simulate_update_packages */
+);
diff -Nru a/backends/pacman/backend-pacman.h b/backends/pacman/backend-pacman.h
--- a/backends/pacman/backend-pacman.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-pacman.h	2010-03-21 10:23:23.350965319 +1300
@@ -0,0 +1,26 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+
+extern PacmanManager	*pacman;
diff -Nru a/backends/pacman/backend-remove.c b/backends/pacman/backend-remove.c
--- a/backends/pacman/backend-remove.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-remove.c	2010-04-05 23:40:45.244455233 +1200
@@ -0,0 +1,149 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-error.h"
+#include "backend-packages.h"
+#include "backend-transaction.h"
+#include "backend-remove.h"
+
+static gboolean
+backend_remove_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	gchar **package_ids;
+	gboolean allow_deps;
+	gboolean autoremove;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	allow_deps = pk_backend_get_bool (backend, "allow_deps");
+	autoremove = pk_backend_get_bool (backend, "autoremove");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* remove packages that depend on those to be removed */
+	if (allow_deps) {
+		flags |= PACMAN_TRANSACTION_FLAGS_REMOVE_CASCADE;
+	}
+	/* remove unneeded packages that were required by those to be removed */
+	if (autoremove) {
+		flags |= PACMAN_TRANSACTION_FLAGS_REMOVE_RECURSIVE;
+	}
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup (package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TYPE_REMOVE, flags, list);
+		pacman_list_free_full (list, g_free);
+	}
+
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_remove_packages:
+ **/
+void
+backend_remove_packages (PkBackend *backend, gchar **package_ids, gboolean allow_deps, gboolean autoremove)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_SETUP);
+	pk_backend_thread_create (backend, backend_remove_packages_thread);
+}
+
+static gboolean
+backend_simulate_remove_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL;
+
+	gchar **package_ids;
+	gboolean autoremove;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_REMOVE_CASCADE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+	autoremove = pk_backend_get_bool (backend, "autoremove");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* remove unneeded packages that were required by those to be removed */
+	if (autoremove) {
+		flags |= PACMAN_TRANSACTION_FLAGS_REMOVE_RECURSIVE;
+	}
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		gchar **package_id_data = pk_package_id_split (package_ids[iterator]);
+		list = pacman_list_add (list, g_strdup (package_id_data[PK_PACKAGE_ID_NAME]));
+		g_strfreev (package_id_data);
+	}
+
+	/* prepare the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_simulate (backend, PACMAN_TYPE_REMOVE, flags, list);
+		if (transaction != NULL) {
+			const PacmanList *packages;
+
+			/* emit packages that would have been removed */
+			for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+				PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+				backend_package (backend, package, PK_INFO_ENUM_REMOVING);
+			}
+		}
+		pacman_list_free_full (list, g_free);
+	}
+
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_simulate_remove_packages:
+ **/
+void
+backend_simulate_remove_packages (PkBackend *backend, gchar **package_ids, gboolean autoremove)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_SETUP);
+	pk_backend_thread_create (backend, backend_simulate_remove_packages_thread);
+}
diff -Nru a/backends/pacman/backend-remove.h b/backends/pacman/backend-remove.h
--- a/backends/pacman/backend-remove.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-remove.h	2010-03-21 10:23:23.354302896 +1300
@@ -0,0 +1,32 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_remove_packages		(PkBackend	*backend,
+						 gchar		**package_ids,
+						 gboolean	 allow_deps,
+						 gboolean	 autoremove);
+void	 backend_simulate_remove_packages	(PkBackend	*backend,
+						 gchar		**package_ids,
+						 gboolean	 autoremove);
diff -Nru a/backends/pacman/backend-repos.c b/backends/pacman/backend-repos.c
--- a/backends/pacman/backend-repos.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-repos.c	2010-04-05 22:44:33.190631315 +1200
@@ -0,0 +1,260 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <gio/gio.h>
+#include "backend-error.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+
+PacmanDatabase *local_database = NULL;
+static GHashTable *disabled_repos = NULL;
+
+static gboolean
+disabled_repos_load (GError **error)
+{
+	GFile *file;
+	GFileInputStream *file_stream;
+	GDataInputStream *data_stream;
+
+	gchar *line;
+	GError *e = NULL;
+
+	g_return_val_if_fail (disabled_repos != NULL, FALSE);
+
+	egg_debug ("pacman: reading disabled repos from %s", PACMAN_REPO_LIST);
+	file = g_file_new_for_path (PACMAN_REPO_LIST);
+	file_stream = g_file_read (file, NULL, &e);
+
+	if (file_stream == NULL) {
+		g_object_unref (file);
+		g_propagate_error (error, e);
+		return FALSE;
+	}
+
+	/* read disabled repos line by line, ignoring comments */
+	data_stream = g_data_input_stream_new (G_INPUT_STREAM (file_stream));
+	while ((line = g_data_input_stream_read_line (data_stream, NULL, NULL, &e)) != NULL) {
+		g_strstrip (line);
+
+		if (*line == '\0' || *line == '#') {
+			g_free (line);
+			continue;
+		}
+
+		g_hash_table_insert (disabled_repos, line, GINT_TO_POINTER (1));
+	}
+
+	g_object_unref (data_stream);
+	g_object_unref (file_stream);
+	g_object_unref (file);
+
+	if (e != NULL) {
+		g_propagate_error (error, e);
+		return FALSE;
+	} else {
+		return TRUE;
+	}
+}
+
+static gboolean
+disabled_repos_save (GError **error)
+{
+	GFile *file;
+	GFileOutputStream *file_stream;
+	GDataOutputStream *data_stream;
+
+	GHashTableIter iter;
+	const gchar *line = PACMAN_REPO_LIST_HEADER "\n";
+	GError *e = NULL;
+
+	g_return_val_if_fail (disabled_repos != NULL, FALSE);
+
+	egg_debug ("pacman: storing disabled repos in %s", PACMAN_REPO_LIST);
+	file = g_file_new_for_path (PACMAN_REPO_LIST);
+	file_stream = g_file_replace (file, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &e);
+
+	if (file_stream == NULL) {
+		g_object_unref (file);
+		g_propagate_error (error, e);
+		return FALSE;
+	}
+
+	/* write header, then all disabled repos line by line */
+	data_stream = g_data_output_stream_new (G_OUTPUT_STREAM (file_stream));
+	if (g_data_output_stream_put_string (data_stream, line, NULL, &e)) {
+		g_hash_table_iter_init (&iter, disabled_repos);
+		while (g_hash_table_iter_next (&iter, (gpointer *) &line, NULL)) {
+			if (!g_data_output_stream_put_string (data_stream, line, NULL, &e)) {
+				break;
+			}
+			if (!g_data_output_stream_put_string (data_stream, "\n", NULL, &e)) {
+				break;
+			}
+		}
+	}
+
+	g_object_unref (data_stream);
+	g_object_unref (file_stream);
+	g_object_unref (file);
+
+	if (e != NULL) {
+		g_propagate_error (error, e);
+		return FALSE;
+	} else {
+		return TRUE;
+	}
+}
+
+gboolean
+backend_initialize_databases (PkBackend *backend)
+{
+	GError *error = NULL;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	local_database = pacman_manager_get_local_database (pacman);
+	disabled_repos = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
+
+	if (disabled_repos_load (&error)) {
+		const PacmanList *databases;
+
+		/* disable disabled repos */
+		for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+			PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+			const gchar *repo = pacman_database_get_name (database);
+
+			if (g_hash_table_lookup (disabled_repos, repo) != NULL) {
+				if (!pacman_manager_unregister_database (pacman, database, &error)) {
+					backend_error (backend, error);
+					return FALSE;
+				}
+			}
+		}
+
+		return TRUE;
+	} else {
+		backend_error (backend, error);
+		return FALSE;
+	}
+}
+
+gboolean
+backend_destroy_databases (PkBackend *backend)
+{
+	gboolean result;
+	GError *error = NULL;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	result = disabled_repos_save (&error);
+
+	if (disabled_repos != NULL) {
+		g_hash_table_unref (disabled_repos);
+	}
+
+	if (!result) {
+		backend_error (backend, error);
+		return FALSE;
+	} else {
+		return TRUE;
+	}
+}
+
+/**
+ * backend_get_repo_list:
+ **/
+void	
+backend_get_repo_list (PkBackend *backend, PkBitfield filters)
+{
+	const PacmanList *databases;
+	GHashTableIter iter;
+	gpointer key, value;
+
+	g_return_if_fail (pacman != NULL);
+	g_return_if_fail (disabled_repos != NULL);
+	g_return_if_fail (backend != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+
+	/* emit enabled repos */
+	for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+		PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+		const gchar *repo = pacman_database_get_name (database);
+
+		pk_backend_repo_detail (backend, repo, repo, TRUE);
+	}
+
+	/* emit disabled repos */
+	g_hash_table_iter_init (&iter, disabled_repos);
+	while (g_hash_table_iter_next (&iter, &key, &value)) {
+		if (value != NULL) {
+			const gchar *repo = (const gchar *) key;
+
+			pk_backend_repo_detail (backend, repo, repo, FALSE);
+		}
+	}
+
+	pk_backend_finished (backend);
+}
+
+/**
+ * backend_repo_enable:
+ **/
+void
+backend_repo_enable (PkBackend *backend, const gchar *repo, gboolean enable)
+{
+	GError *error = NULL;
+
+	g_return_if_fail (pacman != NULL);
+	g_return_if_fail (disabled_repos != NULL);
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (repo != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+
+	if (enable) {
+		/* register database if repo is actually disabled */
+		if (g_hash_table_remove (disabled_repos, repo)) {
+			if (!pacman_manager_register_sync_database (pacman, repo, &error)) {
+				backend_error (backend, error);
+			}
+		} else {
+			pk_backend_error_code (backend, PK_ERROR_ENUM_REPO_NOT_FOUND, "Could not find repo [%s]", repo);
+		}
+	} else {
+		PacmanDatabase *database = pacman_manager_find_sync_database (pacman, repo);
+
+		if (database != NULL) {
+			if (pacman_manager_unregister_database (pacman, database, &error)) {
+				g_hash_table_insert (disabled_repos, g_strdup (repo), GINT_TO_POINTER (1));
+			} else {
+				backend_error (backend, error);
+			}
+		} else {
+			pk_backend_error_code (backend, PK_ERROR_ENUM_REPO_NOT_FOUND, "Could not find repo [%s]", repo);
+		}
+	}
+
+	pk_backend_finished (backend);
+}
diff -Nru a/backends/pacman/backend-repos.h b/backends/pacman/backend-repos.h
--- a/backends/pacman/backend-repos.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-repos.h	2010-04-05 22:45:01.647294496 +1200
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <pk-backend.h>
+
+extern PacmanDatabase	*local_database;
+
+gboolean	 backend_initialize_databases	(PkBackend	*backend);
+gboolean	 backend_destroy_databases	(PkBackend	*backend);
+
+void		 backend_get_repo_list		(PkBackend	*backend,
+						 PkBitfield	 filters);
+void		 backend_repo_enable		(PkBackend	*backend,
+						 const gchar	*repo,
+						 gboolean	 enable);
diff -Nru a/backends/pacman/backend-search.c b/backends/pacman/backend-search.c
--- a/backends/pacman/backend-search.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-search.c	2010-04-05 23:53:14.281050915 +1200
@@ -0,0 +1,398 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-error.h"
+#include "backend-groups.h"
+#include "backend-packages.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+#include "backend-search.h"
+
+static gboolean
+pacman_package_is_installed (PacmanPackage *package)
+{
+	PacmanPackage *installed;
+
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (package != NULL, FALSE);
+
+	/* find an installed package with the same name */
+	installed = pacman_database_find_package (local_database, pacman_package_get_name (package));
+	if (installed == NULL) {
+		return FALSE;
+	}
+
+	/* make sure the installed version is the same */
+	if (pacman_package_compare_version (pacman_package_get_version (installed), pacman_package_get_version (package)) != 0) {
+		return FALSE;
+	}
+
+	/* make sure the installed arch is the same */
+	if (g_strcmp0 (pacman_package_get_arch (installed), pacman_package_get_arch (package)) != 0) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static void
+backend_package_with_database (PkBackend *backend, PacmanPackage *package, PacmanDatabase *database)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package != NULL);
+	g_return_if_fail (database != NULL);
+
+	if (database == local_database) {
+		backend_package (backend, package, PK_INFO_ENUM_INSTALLED);
+	} else if (!pacman_package_is_installed (package)) {
+		backend_package (backend, package, PK_INFO_ENUM_AVAILABLE);
+	}
+}
+
+static gboolean
+backend_match_all (PacmanPackage *package, const gchar *needle)
+{
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (needle != NULL, FALSE);
+
+	/* match all packages */
+	return TRUE;
+}
+
+static gboolean
+backend_match_details (PacmanPackage *package, GRegex *regex)
+{
+	const gchar *description;
+	PacmanDatabase *database;
+	const PacmanList *licenses;
+
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (regex != NULL, FALSE);
+
+	/* match the name first... */
+	if (g_regex_match (regex, pacman_package_get_name (package), 0, NULL)) {
+		return TRUE;
+	}
+
+	/* ... then the description... */
+	description = pacman_package_get_description (package);
+	if (description != NULL && g_regex_match (regex, description, 0, NULL)) {
+		return TRUE;
+	}
+
+	/* ... then the database... */
+	database = pacman_package_get_database (package);
+	if (database != NULL && g_regex_match (regex, pacman_database_get_name (database), G_REGEX_MATCH_ANCHORED, NULL)) {
+		return TRUE;
+	}
+
+	/* ... then the licenses */
+	for (licenses = pacman_package_get_licenses (package); licenses != NULL; licenses = pacman_list_next (licenses)) {
+		const gchar *license = (const gchar *) pacman_list_get (licenses);
+		if (g_regex_match (regex, license, G_REGEX_MATCH_ANCHORED, NULL)) {
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static gboolean
+backend_match_group (PacmanPackage *package, const gchar *needle)
+{
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (needle != NULL, FALSE);
+
+	/* match the group the package is in */
+	return g_strcmp0 (needle, pacman_package_get_group (package)) == 0;
+}
+
+static gboolean
+backend_match_name (PacmanPackage *package, GRegex *regex)
+{
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (regex != NULL, FALSE);
+
+	/* match the name of the package */
+	return g_regex_match (regex, pacman_package_get_name (package), 0, NULL);
+}
+
+static gboolean
+backend_match_provides (PacmanPackage *package, const gchar *needle)
+{
+	/* TODO: implement GStreamer codecs, Pango fonts, etc. */
+	const PacmanList *provides;
+
+	g_return_val_if_fail (package != NULL, FALSE);
+	g_return_val_if_fail (needle != NULL, FALSE);
+
+	/* match features provided by package */
+	for (provides = pacman_package_get_provides (package); provides != NULL; provides = pacman_list_next (provides)) {
+		const gchar *name = (const gchar *) pacman_list_get (provides);
+		if (g_strcmp0 (needle, name) == 0) {
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+typedef enum {
+	SEARCH_TYPE_ALL,
+	SEARCH_TYPE_DETAILS,
+	SEARCH_TYPE_GROUP,
+	SEARCH_TYPE_NAME,
+	SEARCH_TYPE_PROVIDES,
+	SEARCH_TYPE_LAST
+} SearchType;
+
+typedef gboolean (*MatchFunc) (PacmanPackage *package, const gchar *needle);
+typedef gboolean (*RegexMatchFunc) (PacmanPackage *package, GRegex *regex);
+
+static MatchFunc match_funcs[] = {
+	backend_match_all,
+	NULL,
+	backend_match_group,
+	NULL,
+	backend_match_provides
+};
+
+static RegexMatchFunc regex_match_funcs[] = {
+	NULL,
+	backend_match_details,
+	NULL,
+	backend_match_name,
+	NULL
+};
+
+static gboolean
+backend_search_database (PkBackend *backend, PacmanDatabase *database, gchar **search, MatchFunc match)
+{
+	guint iterator;
+	const PacmanList *packages;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+	g_return_val_if_fail (database != NULL, FALSE);
+	g_return_val_if_fail (search != NULL, FALSE);
+	g_return_val_if_fail (match != NULL, FALSE);
+
+	/* emit packages that match all search terms */
+	for (packages = pacman_database_get_packages (database); packages != NULL; packages = pacman_list_next (packages)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+		for (iterator = 0; search[iterator] != NULL; ++iterator) {
+			if (!match (package, search[iterator])) {
+				break;
+			}
+		}
+
+		/* all search terms matched */
+		if (search[iterator] == NULL) {
+			backend_package_with_database (backend, package, database);
+		}
+	}
+
+	return TRUE;
+}
+
+static gboolean
+backend_search_database_regex (PkBackend *backend, PacmanDatabase *database, gchar **search, RegexMatchFunc match)
+{
+	guint iterator;
+	const PacmanList *packages, *list;
+	PacmanList *matches = NULL;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+	g_return_val_if_fail (database != NULL, FALSE);
+	g_return_val_if_fail (search != NULL, FALSE);
+	g_return_val_if_fail (match != NULL, FALSE);
+
+	/* convert search terms to literal regular expressions for fast caseless searching */
+	for (iterator = 0; search[iterator] != NULL; ++iterator) {
+		gchar *pattern;
+		GRegex *regex;
+		GError *error = NULL;
+
+		pattern = g_regex_escape_string (search[iterator], -1);
+		regex = g_regex_new (pattern, G_REGEX_CASELESS, 0, &error);
+		g_free (pattern);
+
+		if (regex != NULL) {
+			matches = pacman_list_add (matches, regex);
+		} else {
+			backend_error (backend, error);
+			pacman_list_free_full (matches, (GDestroyNotify) g_regex_unref);
+			pk_backend_finished (backend);
+			return FALSE;
+		}
+	}
+
+	/* emit packages that match all search terms */
+	for (packages = pacman_database_get_packages (database); packages != NULL; packages = pacman_list_next (packages)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+
+		for (list = matches; list != NULL; list = pacman_list_next (list)) {
+			GRegex *regex = (GRegex *) pacman_list_get (list);
+			if (!match (package, regex)) {
+				break;
+			}
+		}
+
+		/* all search terms matched */
+		if (list == NULL) {
+			backend_package_with_database (backend, package, database);
+		}
+	}
+
+	pacman_list_free_full (matches, (GDestroyNotify) g_regex_unref);
+	return TRUE;
+}
+
+static gboolean
+backend_search_thread (PkBackend *backend)
+{
+	gchar **search;
+	SearchType search_type;
+
+	MatchFunc match_func;
+	RegexMatchFunc regex_match_func;
+
+	PkBitfield filters;
+	gboolean search_installed;
+	gboolean search_not_installed;
+
+	g_return_val_if_fail (pacman != NULL, FALSE);
+	g_return_val_if_fail (local_database != NULL, FALSE);
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	search = pk_backend_get_strv (backend, "search");
+	search_type = (SearchType) pk_backend_get_uint (backend, "search-type");
+
+	g_return_val_if_fail (search != NULL, FALSE);
+	g_return_val_if_fail (search_type < SEARCH_TYPE_LAST, FALSE);
+
+	match_func = match_funcs[search_type];
+	regex_match_func = regex_match_funcs[search_type];
+
+	filters = pk_backend_get_uint (backend, "filters");
+	search_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_INSTALLED);
+	search_not_installed = pk_bitfield_contain (filters, PK_FILTER_ENUM_NOT_INSTALLED);
+
+	/* find installed packages first */
+	if (!search_not_installed) {
+		if (match_func != NULL && !backend_search_database (backend, local_database, search, match_func)) {
+			return FALSE;
+		}
+		if (regex_match_func != NULL && !backend_search_database_regex (backend, local_database, search, regex_match_func)) {
+			return FALSE;
+		}
+	}
+
+	if (!search_installed) {
+		const PacmanList *databases;
+
+		for (databases = pacman_manager_get_sync_databases (pacman); databases != NULL; databases = pacman_list_next (databases)) {
+			PacmanDatabase *database = (PacmanDatabase *) pacman_list_get (databases);
+			if (match_func != NULL && !backend_search_database (backend, database, search, match_func)) {
+				return FALSE;
+			}
+			if (regex_match_func != NULL && !backend_search_database_regex (backend, database, search, regex_match_func)) {
+				return FALSE;
+			}
+		}
+	}
+
+	pk_backend_finished (backend);
+	return TRUE;
+}
+
+/**
+ * backend_get_packages:
+ **/
+void
+backend_get_packages (PkBackend	*backend, PkBitfield filters)
+{
+	g_return_if_fail (backend != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+	pk_backend_set_strv (backend, "search", g_strsplit ("", ";", 0));
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_ALL);
+	pk_backend_thread_create (backend, backend_search_thread);
+}
+
+/**
+ * backend_search_details:
+ **/
+void
+backend_search_details (PkBackend *backend, PkBitfield filters, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_DETAILS);
+	pk_backend_thread_create (backend, backend_search_thread);
+}
+
+/**
+ * backend_search_groups:
+ **/
+void
+backend_search_groups (PkBackend *backend, PkBitfield filters, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_GROUP);
+	pk_backend_thread_create (backend, backend_search_thread);
+}
+
+/**
+ * backend_search_names:
+ **/
+void
+backend_search_names (PkBackend *backend, PkBitfield filters, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_NAME);
+	pk_backend_thread_create (backend, backend_search_thread);
+}
+
+/**
+ * backend_what_provides:
+ **/
+void
+backend_what_provides (PkBackend *backend, PkBitfield filters, PkProvidesEnum provides, gchar **values)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (values != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+	pk_backend_set_uint (backend, "search-type", SEARCH_TYPE_PROVIDES);
+	pk_backend_thread_create (backend, backend_search_thread);
+}
diff -Nru a/backends/pacman/backend-search.h b/backends/pacman/backend-search.h
--- a/backends/pacman/backend-search.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-search.h	2010-03-21 10:23:23.354302896 +1300
@@ -0,0 +1,40 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_get_packages	(PkBackend	*backend,
+				 PkBitfield	 filters);
+void	 backend_search_details	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**values);
+void	 backend_search_groups	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**values);
+void	 backend_search_names	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 gchar		**values);
+void	 backend_what_provides	(PkBackend	*backend,
+				 PkBitfield	 filters,
+				 PkProvidesEnum	 provides,
+				 gchar		**values);
diff -Nru a/backends/pacman/backend-transaction.c b/backends/pacman/backend-transaction.c
--- a/backends/pacman/backend-transaction.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-transaction.c	2010-04-05 23:55:10.663541029 +1200
@@ -0,0 +1,501 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <string.h>
+#include "backend-error.h"
+#include "backend-packages.h"
+#include "backend-pacman.h"
+#include "backend-repos.h"
+#include "backend-transaction.h"
+
+typedef struct {
+	guint complete;
+	guint total;
+
+	PacmanPackage *package;
+	GString *files;
+} BackendDownloadData;
+
+static GHashTable *downloads = NULL;
+
+gboolean
+backend_initialize_downloads (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	downloads = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);
+	return TRUE;
+}
+
+gboolean
+backend_destroy_downloads (PkBackend *backend)
+{
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	g_hash_table_unref (downloads);
+	return TRUE;
+}
+
+static void
+transaction_download_end (PacmanTransaction *transaction, BackendDownloadData *download, PkBackend *backend) {
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (download != NULL);
+	g_return_if_fail (backend != NULL);
+
+	/* emit the finished signal for the old package */
+	backend_package (backend, download->package, PK_INFO_ENUM_FINISHED);
+
+	/* emit the list of files downloaded for DownloadPackages */
+	if (download->files != NULL) {
+		gchar *package_id, *files;
+
+		package_id = pacman_package_make_id (download->package);
+		files = g_string_free (download->files, FALSE);
+
+		pk_backend_files (backend, package_id, files);
+
+		g_free (package_id);
+		g_free (files);
+	}
+
+	download->package = NULL;
+	download->files = NULL;
+}
+
+static gchar *
+backend_filename_make_path (PkBackend *backend, const gchar *filename)
+{
+	const gchar *directory;
+
+	g_return_val_if_fail (backend != NULL, NULL);
+	g_return_val_if_fail (filename != NULL, NULL);
+
+	directory = pk_backend_get_string (backend, "directory");
+
+	g_return_val_if_fail (directory != NULL, NULL);
+
+	return g_build_filename (directory, filename, NULL);
+}
+
+static void
+transaction_download_start (PacmanTransaction *transaction, BackendDownloadData *download, const gchar *filename, PkBackend *backend)
+{
+	const PacmanList *packages;
+
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (download != NULL);
+	g_return_if_fail (filename != NULL);
+	g_return_if_fail (backend != NULL);
+
+	/* continue or finish downloading the old package */
+	if (download->package != NULL) {
+		if (pacman_package_has_filename (download->package, filename)) {
+			if (download->files != NULL) {
+				gchar *path = backend_filename_make_path (backend, filename);
+				g_string_append_printf (download->files, ";%s", path);
+				g_free (path);
+			}
+			return;
+		} else {
+			transaction_download_end (transaction, download, backend);
+		}
+	}
+
+	/* find a new package for the current file */
+	for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+		PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+		if (pacman_package_has_filename (package, filename)) {
+			download->package = package;
+			break;
+		}
+	}
+
+	/* emit the downloading signal and start collecting files for the new package */
+	if (download->package != NULL) {
+		backend_package (backend, download->package, PK_INFO_ENUM_DOWNLOADING);
+
+		/* only emit files downloaded for DownloadPackages */
+		if (pk_backend_get_role (backend) == PK_ROLE_ENUM_DOWNLOAD_PACKAGES) {
+			gchar *path = backend_filename_make_path (backend, filename);
+			download->files = g_string_new (path);
+			g_free (path);
+		}
+	}
+}
+
+static void
+transaction_download_cb (PacmanTransaction *transaction, const gchar *filename, guint complete, guint total, gpointer user_data)
+{
+	BackendDownloadData *download;
+
+	g_return_if_fail (pacman != NULL);
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (user_data != NULL);
+
+	download = (BackendDownloadData *) g_hash_table_lookup (downloads, transaction);
+
+	if (filename == NULL) {
+		if (download == NULL) {
+			/* start a new download */
+			download = g_new0 (BackendDownloadData, 1);
+			download->complete = complete;
+			download->total = total;
+			g_hash_table_insert (downloads, transaction, download);
+		} else {
+			/* finish the current download */
+			if (download->package != NULL) {
+				transaction_download_end (transaction, download, (PkBackend *) user_data);
+			}
+			g_hash_table_remove (downloads, transaction);
+		}
+	} else {
+		guint percentage = 0, sub_percentage = 0;
+
+		g_return_if_fail (download != NULL);
+
+		if (total > 0) {
+			sub_percentage = complete * 100 / total;
+		}
+
+		if (strstr (filename, ".db.tar.") != NULL) {
+			const PacmanList *databases = pacman_manager_get_sync_databases (pacman);
+			guint database_total = pacman_list_length (databases);
+
+			/* report download progress for databases */
+			if (database_total > 0) {
+				percentage = (sub_percentage + download->complete * 100) / database_total;
+			}
+
+			if (complete == total) {
+				download->complete += 1;
+			} else if (complete == 0) {
+				egg_debug ("pacman: downloading database %s", filename);
+				pk_backend_set_status ((PkBackend *) user_data, PK_STATUS_ENUM_REFRESH_CACHE);
+			}
+		} else {
+			/* report download progress for package or delta files */
+			if (download->total > 0) {
+				percentage = (download->complete + complete) * 100 / download->total;
+			}
+
+			if (complete == total) {
+				download->complete += complete;
+			} else if (complete == 0) {
+				egg_debug ("pacman: downloading package %s", filename);
+				pk_backend_set_status ((PkBackend *) user_data, PK_STATUS_ENUM_DOWNLOAD);
+				transaction_download_start (transaction, download, filename, (PkBackend *) user_data);
+			}
+		}
+
+		pk_backend_set_sub_percentage ((PkBackend *) user_data, sub_percentage);
+		pk_backend_set_percentage ((PkBackend *) user_data, percentage);
+	}
+}
+
+static void
+transaction_progress_cb (PacmanTransaction *transaction, PacmanTransactionProgress type, const gchar *target, guint percent, guint current, guint targets, gpointer user_data)
+{
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (user_data != NULL);
+
+	g_return_if_fail (percent >= 0);
+	g_return_if_fail (percent <= 100);
+	g_return_if_fail (current >= 1);
+	g_return_if_fail (current <= targets);
+
+	/* update transaction progress */
+	switch (type) {
+		case PACMAN_TRANSACTION_PROGRESS_INSTALL:
+		case PACMAN_TRANSACTION_PROGRESS_UPGRADE:
+		case PACMAN_TRANSACTION_PROGRESS_REMOVE:
+		case PACMAN_TRANSACTION_PROGRESS_FILE_CONFLICT_CHECK:
+		{
+			egg_debug ("pacman: progress for %s (%u of %u) is %u%%", target, current, targets, percent);
+			pk_backend_set_sub_percentage ((PkBackend *) user_data, percent);
+			pk_backend_set_percentage ((PkBackend *) user_data, (percent + (current - 1) * 100) / targets);
+			break;
+		}
+		default:
+			egg_debug ("pacman: progress of type %d (%u of %u) is %u%%", type, current, targets, percent);
+			break;
+	}
+}
+
+static gboolean
+transaction_question_cb (PacmanTransaction *transaction, PacmanTransactionQuestion question, const gchar *message, gpointer user_data)
+{
+	g_return_val_if_fail (transaction != NULL, FALSE);
+	g_return_val_if_fail (user_data != NULL, FALSE);
+
+	switch (question) {
+		case PACMAN_TRANSACTION_QUESTION_INSTALL_IGNORE_PACKAGE:
+		{
+			PkRoleEnum role = pk_backend_get_role ((PkBackend *) user_data);
+			if (role == PK_ROLE_ENUM_INSTALL_PACKAGES || role == PK_ROLE_ENUM_SIMULATE_INSTALL_PACKAGES) {
+				gchar *packages = pacman_package_make_list (pacman_transaction_get_marked_packages (transaction));
+				gchar *warning = g_strdup_printf ("The following packages were marked as ignored:\n%s\n", packages);
+
+				/* ignored packages are blocked in updates, can be explicitly installed */
+				egg_warning ("pacman: %s", warning);
+				backend_message ((PkBackend *) user_data, warning);
+
+				g_free (warning);
+				g_free (packages);
+				return TRUE;
+			} else if (role == PK_ROLE_ENUM_GET_UPDATES) {
+				const PacmanList *packages;
+
+				for (packages = pacman_transaction_get_marked_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+					PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+					backend_package ((PkBackend *) user_data, package, PK_INFO_ENUM_BLOCKED);
+				}
+
+				return FALSE;
+			} else {
+				return FALSE;
+			}
+		}
+		case PACMAN_TRANSACTION_QUESTION_REPLACE_PACKAGE:
+		{
+			PacmanConflict *conflict = (PacmanConflict *) pacman_list_get (pacman_transaction_get_conflicts (transaction));
+			const gchar *first = pacman_conflict_get_second_package (conflict), *second = pacman_conflict_get_first_package (conflict);
+			gchar *warning = g_strdup_printf ("Package %s has been replaced with %s\n", second, first);
+
+			/* replacement is usually safe */
+			egg_warning ("pacman: %s", warning);
+			backend_message ((PkBackend *) user_data, warning);
+
+			g_free (warning);
+			return TRUE;
+		}
+		case PACMAN_TRANSACTION_QUESTION_SYNC_FIRST:
+		{
+			PkRoleEnum role = pk_backend_get_role ((PkBackend *) user_data);
+			if (role == PK_ROLE_ENUM_GET_UPDATES) {
+				const PacmanList *packages;
+
+				for (packages = pacman_transaction_get_marked_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+					PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+					backend_package ((PkBackend *) user_data, package, PK_INFO_ENUM_IMPORTANT);
+				}
+
+				return FALSE;
+			} else {
+				gchar *packages = pacman_package_make_list (pacman_transaction_get_marked_packages (transaction));
+				gchar *warning = g_strdup_printf ("The following packages should probably have been installed first:\n%s\n", packages);
+
+				/* sync first packages are marked as important in updates */
+				egg_warning ("pacman: %s", warning);
+				backend_message ((PkBackend *) user_data, warning);
+
+				g_free (warning);
+				g_free (packages);
+				return FALSE;
+			}
+		}
+		case PACMAN_TRANSACTION_QUESTION_REMOVE_CONFLICTING_PACKAGE:
+		case PACMAN_TRANSACTION_QUESTION_SKIP_UNRESOLVABLE_PACKAGES:
+		case PACMAN_TRANSACTION_QUESTION_REMOVE_HOLD_PACKAGES:
+			/* none of these actions are safe */
+			egg_warning ("pacman: ignoring question '%s'", message);
+			return FALSE;
+
+		case PACMAN_TRANSACTION_QUESTION_INSTALL_OLDER_PACKAGE:
+		case PACMAN_TRANSACTION_QUESTION_DELETE_CORRUPTED_PACKAGE:
+			/* these actions are mostly harmless */
+			egg_warning ("pacman: confirming question '%s'", message);
+			return TRUE;
+
+		default:
+			egg_warning ("pacman: unrecognised question '%s'", message);
+			return FALSE;
+	}
+}
+
+static void
+transaction_status_cb (PacmanTransaction *transaction, PacmanTransactionStatus status, const gchar *message, gpointer user_data)
+{
+	PkStatusEnum state;
+	PkInfoEnum info;
+
+	g_return_if_fail (transaction != NULL);
+	g_return_if_fail (user_data != NULL);
+
+	/* figure out the backend status and package info */
+	switch (status) {
+		case PACMAN_TRANSACTION_STATUS_INSTALL_START:
+			state = PK_STATUS_ENUM_INSTALL;
+			info = PK_INFO_ENUM_INSTALLING;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_UPGRADE_START:
+			state = PK_STATUS_ENUM_UPDATE;
+			info = PK_INFO_ENUM_UPDATING;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_REMOVE_START:
+			state = PK_STATUS_ENUM_REMOVE;
+			info = PK_INFO_ENUM_REMOVING;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_INSTALL_END:
+		case PACMAN_TRANSACTION_STATUS_UPGRADE_END:
+		case PACMAN_TRANSACTION_STATUS_REMOVE_END:
+			state = PK_STATUS_ENUM_UNKNOWN;
+			info = PK_INFO_ENUM_FINISHED;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_DEPENDENCY_CHECK_START:
+		case PACMAN_TRANSACTION_STATUS_DEPENDENCY_RESOLVE_START:
+			state = PK_STATUS_ENUM_DEP_RESOLVE;
+			info = PK_INFO_ENUM_UNKNOWN;
+			break;
+
+		case PACMAN_TRANSACTION_STATUS_FILE_CONFLICT_CHECK_START:
+		case PACMAN_TRANSACTION_STATUS_CONFLICT_CHECK_START:
+		case PACMAN_TRANSACTION_STATUS_PACKAGE_INTEGRITY_CHECK_START:
+		case PACMAN_TRANSACTION_STATUS_DELTA_INTEGRITY_CHECK_START:
+			state = PK_STATUS_ENUM_TEST_COMMIT;
+			info = PK_INFO_ENUM_UNKNOWN;
+			break;
+
+		default:
+			state = PK_STATUS_ENUM_UNKNOWN;
+			info = PK_INFO_ENUM_UNKNOWN;
+			egg_debug ("pacman: %s", message);
+			break;
+	}
+
+	/* update the backend status */
+	if (state != PK_STATUS_ENUM_UNKNOWN) {
+		pk_backend_set_status ((PkBackend *) user_data, state);
+	}
+
+	/* update the package info */
+	if (info != PK_INFO_ENUM_UNKNOWN) {
+		const PacmanList *packages;
+
+		for (packages = pacman_transaction_get_marked_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+			PacmanPackage *package;
+
+			/* only report the old versions */
+			if (status == PACMAN_TRANSACTION_STATUS_UPGRADE_START || status == PACMAN_TRANSACTION_STATUS_UPGRADE_END) {
+				packages = pacman_list_next (packages);
+				if (packages == NULL) {
+					break;
+				}
+			}
+
+			package = (PacmanPackage *) pacman_list_get (packages);
+			backend_package ((PkBackend *) user_data, package, info);
+		}
+	}
+}
+
+PacmanTransaction *
+backend_transaction_simulate (PkBackend *backend, GType type, guint32 flags, const PacmanList *targets)
+{
+	PacmanTransaction *transaction;
+	GError *error = NULL;
+
+	g_return_val_if_fail (pacman != NULL, NULL);
+	g_return_val_if_fail (backend != NULL, NULL);
+
+	if (type == PACMAN_TYPE_INSTALL) {
+		transaction = pacman_manager_install (pacman, flags, &error);
+	} else if (type == PACMAN_TYPE_REMOVE) {
+		transaction = pacman_manager_remove (pacman, flags, &error);
+	} else if (type == PACMAN_TYPE_SYNC) {
+		transaction = pacman_manager_sync (pacman, flags, &error);
+	} else if (type == PACMAN_TYPE_UPDATE) {
+		transaction = pacman_manager_update (pacman, flags, &error);
+	} else {
+		g_return_val_if_reached (NULL);
+	}
+
+	if (transaction == NULL) {
+		backend_error (backend, error);
+		return NULL;
+	}
+
+	g_signal_connect (transaction, "download", G_CALLBACK (transaction_download_cb), backend);
+	g_signal_connect (transaction, "progress", G_CALLBACK (transaction_progress_cb), backend);
+	g_signal_connect (transaction, "question", G_CALLBACK (transaction_question_cb), backend);
+	g_signal_connect (transaction, "status", G_CALLBACK (transaction_status_cb), backend);
+
+	if (!pacman_transaction_prepare (transaction, targets, &error)) {
+		backend_error (backend, error);
+		g_object_unref (transaction);
+		return NULL;
+	}
+
+	return transaction;
+}
+
+PacmanTransaction *
+backend_transaction_run (PkBackend *backend, GType type, guint32 flags, const PacmanList *targets)
+{
+	PacmanTransaction *transaction;
+	GError *error = NULL;
+
+	g_return_val_if_fail (backend != NULL, NULL);
+
+	transaction = backend_transaction_simulate (backend, type, flags, targets);
+
+	if (transaction != NULL) {
+		pk_backend_set_status (backend, PK_STATUS_ENUM_RUNNING);
+
+		if (!pacman_transaction_commit (transaction, &error)) {
+			backend_error (backend, error);
+			g_hash_table_remove (downloads, transaction);
+			g_object_unref (transaction);
+			return NULL;
+		}
+	}
+
+	return transaction;
+}
+
+gboolean
+backend_transaction_finish (PkBackend *backend, PacmanTransaction *transaction)
+{
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	if (transaction != NULL) {
+		g_object_unref (transaction);
+		pk_backend_finished (backend);
+		return TRUE;
+	} else {
+		pk_backend_finished (backend);
+		return FALSE;
+	}
+}
+
+/**
+ * backend_cancel:
+ **/
+void
+backend_cancel (PkBackend *backend)
+{
+	/* TODO: implement */
+}
diff -Nru a/backends/pacman/backend-transaction.h b/backends/pacman/backend-transaction.h
--- a/backends/pacman/backend-transaction.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-transaction.h	2010-04-05 23:36:30.573655211 +1200
@@ -0,0 +1,41 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include <pk-backend.h>
+
+gboolean		 backend_initialize_downloads	(PkBackend		*backend);
+gboolean		 backend_destroy_downloads	(PkBackend		*backend);
+
+PacmanTransaction	*backend_transaction_simulate	(PkBackend		*backend,
+							 GType			 type,
+							 guint32		 flags,
+							 const PacmanList	*targets);
+PacmanTransaction	*backend_transaction_run	(PkBackend		*backend,
+							 GType			 type,
+							 guint32		 flags,
+							 const PacmanList	*targets);
+
+gboolean		 backend_transaction_finish	(PkBackend		*backend,
+							 PacmanTransaction	*transaction);
+void			 backend_cancel			(PkBackend		*backend);
diff -Nru a/backends/pacman/backend-update.c b/backends/pacman/backend-update.c
--- a/backends/pacman/backend-update.c	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-update.c	2010-04-06 00:10:49.323445999 +1200
@@ -0,0 +1,347 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pacman.h>
+#include "backend-error.h"
+#include "backend-pacman.h"
+#include "backend-packages.h"
+#include "backend-repos.h"
+#include "backend-transaction.h"
+#include "backend-update.h"
+
+static PacmanList *
+pacman_removes_add_replaces (PacmanList *removes, PacmanPackage *package)
+{
+	const PacmanList *list;
+
+	g_return_val_if_fail (local_database != NULL, NULL);
+	g_return_val_if_fail (package != NULL, NULL);
+
+	/* append the packages that package replaces */
+	for (list = pacman_package_get_replaces (package); list != NULL; list = pacman_list_next (list)) {
+		const gchar *name = pacman_list_get (list);
+		PacmanPackage *replaces = pacman_database_find_package (local_database, name);
+
+		if (replaces != NULL && pacman_list_find_string (removes, name) == NULL) {
+			removes = pacman_list_add (removes, g_strdup (name));
+		}
+	}
+
+	return removes;
+}
+
+static gchar *
+pacman_package_make_replaces_ids (PacmanPackage *package)
+{
+	const PacmanList *list;
+	GString *string = NULL;
+
+	g_return_val_if_fail (local_database != NULL, NULL);
+	g_return_val_if_fail (package != NULL, NULL);
+
+	/* make a list of the packages that package replaces */
+	for (list = pacman_package_get_replaces (package); list != NULL; list = pacman_list_next (list)) {
+		const gchar *name = pacman_list_get (list);
+		PacmanPackage *replaces = pacman_database_find_package (local_database, name);
+
+		if (replaces != NULL) {
+			gchar *package_id = pacman_package_make_id (replaces);
+			if (string == NULL) {
+				string = g_string_new (package_id);
+			} else {
+				g_string_append_printf (string, "&%s", package_id);
+			}
+			g_free (package_id);
+		}
+	}
+
+	if (string != NULL) {
+		return g_string_free (string, FALSE);
+	} else {
+		return NULL;
+	}
+}
+
+static gchar *
+pacman_package_make_vendor_url (PacmanPackage *package)
+{
+#ifdef PACMAN_PACKAGE_URL
+	const gchar *name, *arch, *repo, *url;
+#else
+	const gchar *url;
+#endif
+
+	g_return_val_if_fail (package != NULL, NULL);
+
+	/* grab the URL of the package... */
+	url = pacman_package_get_url (package);
+
+#ifdef PACMAN_PACKAGE_URL
+	/* ... and construct the distro URL if possible */
+	name = pacman_package_get_name (package);
+	arch = pacman_package_get_arch (package);
+	repo = pacman_database_get_name (pacman_package_get_database (package));
+
+	return g_strdup_printf ("%s;Package website;" PACMAN_PACKAGE_URL ";Distribution website", url, repo, arch, name);
+#else
+	return g_strdup_printf ("%s;Package website", url);
+#endif
+}
+
+/**
+ * backend_get_update_detail:
+ **/
+void
+backend_get_update_detail (PkBackend *backend, gchar **package_ids)
+{
+	guint iterator;
+
+	g_return_if_fail (local_database != NULL);
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	/* TODO: threads everywhere */
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+
+	/* collect details about updates */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package, *upgrades;
+		PacmanDatabase *database;
+
+		gchar *upgrades_id, *replaces_ids, *vendor_url;
+		const gchar *message;
+
+		PkRestartEnum restart;
+		PkUpdateStateEnum state;
+
+		package = backend_get_package (backend, package_ids[iterator]);
+		if (package == NULL) {
+			pk_backend_finished (backend);
+			return;
+		}
+
+		upgrades = pacman_database_find_package (local_database, pacman_package_get_name (package));
+		if (upgrades != NULL) {
+			upgrades_id = pacman_package_make_id (upgrades);
+			message = "Update to latest available version";
+		} else {
+			upgrades_id = NULL;
+			message = "Install as a dependency for another update";
+		}
+
+		database = pacman_package_get_database (package);
+		replaces_ids = pacman_package_make_replaces_ids (package);
+		vendor_url = pacman_package_make_vendor_url (package);
+
+		if (g_str_has_prefix (pacman_package_get_name (package), "kernel")) {
+			restart = PK_RESTART_ENUM_SYSTEM;
+		} else {
+			restart = PK_RESTART_ENUM_NONE;
+		}
+
+		if (g_str_has_suffix (pacman_database_get_name (database), "testing")) {
+			state = PK_UPDATE_STATE_ENUM_TESTING;
+		} else {
+			state = PK_UPDATE_STATE_ENUM_STABLE;
+		}
+
+		pk_backend_update_detail (backend, package_ids[iterator], upgrades_id, replaces_ids, vendor_url, NULL, NULL, restart, message, NULL, state, NULL, NULL);
+
+		g_free (vendor_url);
+		g_free (replaces_ids);
+		g_free (upgrades_id);
+	}
+
+	pk_backend_finished (backend);
+}
+
+static gboolean
+backend_get_updates_thread (PkBackend *backend)
+{
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	/* prepare the transaction */
+	transaction = backend_transaction_simulate (backend, PACMAN_TYPE_SYNC, flags, NULL);
+	if (transaction != NULL) {
+		const PacmanList *packages;
+
+		/* emit packages that need updating */
+		for (packages = pacman_transaction_get_packages (transaction); packages != NULL; packages = pacman_list_next (packages)) {
+			PacmanPackage *package = (PacmanPackage *) pacman_list_get (packages);
+			backend_package (backend, package, PK_INFO_ENUM_NORMAL);
+		}
+	}
+
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_get_updates:
+ **/
+void
+backend_get_updates (PkBackend *backend, PkBitfield filters)
+{
+	g_return_if_fail (backend != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
+	pk_backend_thread_create (backend, backend_get_updates_thread);
+}
+
+static gboolean
+backend_refresh_cache_thread (PkBackend *backend)
+{
+	gboolean force;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	force = pk_backend_get_bool (backend, "force");
+
+	/* download databases even if they are older than current */
+	if (force) {
+		flags |= PACMAN_TRANSACTION_FLAGS_UPDATE_ALLOW_DOWNGRADE;
+	}
+
+	/* run the transaction */
+	transaction = backend_transaction_run (backend, PACMAN_TYPE_UPDATE, flags, NULL);
+
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_refresh_cache:
+ **/
+void
+backend_refresh_cache (PkBackend *backend, gboolean force)
+{
+	g_return_if_fail (backend != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_SETUP);
+	pk_backend_thread_create (backend, backend_refresh_cache_thread);
+}
+
+static gboolean
+backend_update_packages_thread (PkBackend *backend)
+{
+	guint iterator;
+	PacmanList *list = NULL, *removes = NULL;
+
+	/* TODO: use only_trusted once pacman implements package signing */
+	gchar **package_ids;
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE, rflags = PACMAN_TRANSACTION_FLAGS_IGNORE_DEPENDENCIES;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	package_ids = pk_backend_get_strv (backend, "package_ids");
+
+	g_return_val_if_fail (package_ids != NULL, FALSE);
+
+	/* collect targets for the transaction */
+	for (iterator = 0; package_ids[iterator] != NULL; ++iterator) {
+		PacmanPackage *package = backend_get_package (backend, package_ids[iterator]);
+		if (package == NULL) {
+			pacman_list_free_full (list, g_free);
+			pacman_list_free_full (removes, g_free);
+			pk_backend_finished (backend);
+			return FALSE;
+		} else {
+			PacmanDatabase *database = pacman_package_get_database (package);
+			const gchar *name = pacman_package_get_name (package);
+			const gchar *repo = pacman_database_get_name (database);
+
+			list = pacman_list_add (list, g_strdup_printf ("%s/%s", repo, name));
+			removes = pacman_removes_add_replaces (removes, package);
+		}
+	}
+
+	/* remove all obsoleted packages */
+	if (removes != NULL) {
+		pk_backend_set_status (backend, PK_STATUS_ENUM_OBSOLETE);
+		transaction = backend_transaction_run (backend, PACMAN_TYPE_REMOVE, rflags, removes);
+		pacman_list_free_full (removes, g_free);
+
+		if (transaction != NULL) {
+			g_object_unref (transaction);
+		} else {
+			pacman_list_free_full (list, g_free);
+			pk_backend_finished (backend);
+			return FALSE;
+		}
+	}
+
+	/* run the transaction */
+	if (list != NULL) {
+		transaction = backend_transaction_run (backend, PACMAN_TYPE_SYNC, flags, list);
+		pacman_list_free_full (list, g_free);
+	}
+
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_update_packages:
+ **/
+void
+backend_update_packages (PkBackend *backend, gboolean only_trusted, gchar **package_ids)
+{
+	g_return_if_fail (backend != NULL);
+	g_return_if_fail (package_ids != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_SETUP);
+	pk_backend_thread_create (backend, backend_update_packages_thread);
+}
+
+static gboolean
+backend_update_system_thread (PkBackend *backend)
+{
+	/* TODO: use only_trusted once pacman implements package signing */
+
+	PacmanTransaction *transaction = NULL;
+	PacmanTransactionFlags flags = PACMAN_TRANSACTION_FLAGS_NONE;
+
+	g_return_val_if_fail (backend != NULL, FALSE);
+
+	/* run the transaction */
+	transaction = backend_transaction_run (backend, PACMAN_TYPE_SYNC, flags, NULL);
+
+	return backend_transaction_finish (backend, transaction);
+}
+
+/**
+ * backend_update_system:
+ **/
+void
+backend_update_system (PkBackend *backend, gboolean only_trusted)
+{
+	g_return_if_fail (backend != NULL);
+
+	pk_backend_set_status (backend, PK_STATUS_ENUM_SETUP);
+	pk_backend_thread_create (backend, backend_update_system_thread);
+}
diff -Nru a/backends/pacman/backend-update.h b/backends/pacman/backend-update.h
--- a/backends/pacman/backend-update.h	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/backend-update.h	2010-04-05 23:06:55.187162989 +1200
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Andreas Obergrusberger <tradiaz@yahoo.de>
+ * Copyright (C) 2008, 2009 Valeriy Lyasotskiy <onestep@ukr.net>
+ * Copyright (C) 2010 Jonathan Conder <j@skurvy.no-ip.org>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <pk-backend.h>
+
+void	 backend_get_update_detail	(PkBackend	*backend,
+					 gchar		**package_ids);
+void	 backend_get_updates		(PkBackend	*backend,
+					 PkBitfield	 filters);
+void	 backend_refresh_cache		(PkBackend	*backend,
+					 gboolean	 force);
+void	 backend_update_packages	(PkBackend	*backend,
+					 gboolean	 only_trusted,
+					 gchar		**package_ids);
+void	 backend_update_system		(PkBackend	*backend,
+					 gboolean	 only_trusted);
diff -Nru a/backends/pacman/groups.list b/backends/pacman/groups.list
--- a/backends/pacman/groups.list	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/groups.list	2010-03-21 10:23:23.357630694 +1300
@@ -0,0 +1,65 @@
+adesklet-desklets	desktop-other
+base			system
+base-devel		programming
+bmp-io-plugins		multimedia
+bmp-plugins		multimedia
+cegcc			programming
+compiz			desktop-other
+compiz-fusion		desktop-other
+compiz-fusion-gtk	desktop-gnome
+compiz-fusion-kde	desktop-kde
+compiz-gnome		desktop-gnome
+compiz-gtk		desktop-gnome
+compiz-kde		desktop-kde
+e17-extra-svn		desktop-other
+e17-libs-svn		desktop-other
+e17-svn			desktop-other
+fprint			other
+gimp-help		other
+gimp-plugins		other
+gnome			desktop-gnome
+gnome-extra		desktop-gnome
+gnustep-core		desktop-other
+google-gadgets		desktop-other
+gstreamer0.10-plugins	multimedia
+kde			desktop-kde
+kdeaccessibility	desktop-kde
+kdeadmin		desktop-kde
+kdeartwork		desktop-kde
+kdebase			desktop-kde
+kdeedu			desktop-kde
+kde-extragear		desktop-kde
+kdegames		desktop-kde
+kdegraphics		desktop-kde
+kde-l10n		desktop-kde
+kde-meta		desktop-kde
+kdemultimedia		desktop-kde
+kdenetwork		desktop-kde
+kdepim			desktop-kde
+kdeplasma-addons	desktop-kde
+kdesdk			desktop-kde
+kdetoys			desktop-kde
+kdeutils		desktop-kde
+kdewebdev		desktop-kde
+koffice			desktop-kde
+ladspa-plugins		multimedia
+lib32			other
+lxde			other
+qtcurve			desktop-kde
+rox-desktop		desktop-other
+telepathy		other
+texlive-lang		other
+texlive-lang-doc	other
+texlive-most		other
+texlive-most-doc	other
+thunderbird-i18n	other
+thunderbird-spell-i18n	other
+vim-plugins		other
+xfce4			desktop-xfce
+xfce4-goodies		desktop-xfce
+xmms-effect-plugins	multimedia
+xmms-io-plugins		multimedia
+xmms-plugins		multimedia
+xorg			desktop-other
+xorg-input-drivers	desktop-other
+xorg-video-drivers	desktop-other
diff -Nru a/backends/pacman/Makefile.am b/backends/pacman/Makefile.am
--- a/backends/pacman/Makefile.am	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/Makefile.am	2010-04-02 13:09:45.333751761 +1300
@@ -0,0 +1,46 @@
+PACMAN_CONFIG_FILE = $(confdir)/pacman.conf
+PACMAN_GROUP_LIST = $(confdir)/groups.list
+PACMAN_REPO_LIST = $(confdir)/repos.list
+PACMAN_REPO_LIST_HEADER = "\# Generated by $(PACKAGE_NAME) - DO NOT MODIFY"
+PACMAN_DEFAULT_PATH = "/bin:/usr/bin:/sbin:/usr/sbin"
+PACMAN_PACKAGE_URL = "http://www.archlinux.org/packages/%s/%s/%s/"
+
+DEFS = -DPACMAN_CONFIG_FILE=\"$(PACMAN_CONFIG_FILE)\" \
+       -DPACMAN_GROUP_LIST=\"$(PACMAN_GROUP_LIST)\" \
+       -DPACMAN_REPO_LIST=\"$(PACMAN_REPO_LIST)\" \
+       -DPACMAN_REPO_LIST_HEADER=\"$(PACMAN_REPO_LIST_HEADER)\" \
+       -DPACMAN_DEFAULT_PATH=\"$(PACMAN_DEFAULT_PATH)\" \
+       -DPACMAN_PACKAGE_URL=\"$(PACMAN_PACKAGE_URL)\"
+
+confdir = $(PK_CONF_DIR)/pacman.d
+conf_DATA = groups.list \
+            pacman.conf \
+            repos.list
+
+plugindir = $(PK_PLUGIN_DIR)
+plugin_LTLIBRARIES = libpk_backend_pacman.la
+
+libpk_backend_pacman_la_SOURCES = backend-depends.c \
+                                  backend-error.c \
+                                  backend-groups.c \
+                                  backend-install.c \
+                                  backend-packages.c \
+                                  backend-pacman.c \
+                                  backend-remove.c \
+                                  backend-repos.c \
+                                  backend-search.c \
+                                  backend-transaction.c \
+                                  backend-update.c
+
+libpk_backend_pacman_la_LIBADD = $(PK_PLUGIN_LIBS) \
+                                 $(PACMAN_LIBS)
+libpk_backend_pacman_la_LDFLAGS = -module -avoid-version
+libpk_backend_pacman_la_CFLAGS = $(PK_PLUGIN_CFLAGS) \
+                                 $(PACMAN_CFLAGS) \
+                                 $(WARNINGFLAGS_C)
+repos.list:
+	echo $(PACMAN_REPO_LIST_HEADER) > $@
+
+BUILT_SOURCES = repos.list
+
+EXTRA_DIST = $(conf_DATA)
diff -Nru a/backends/pacman/pacman.conf b/backends/pacman/pacman.conf
--- a/backends/pacman/pacman.conf	1970-01-01 12:00:00.000000000 +1200
+++ b/backends/pacman/pacman.conf	2010-03-21 10:23:23.357630694 +1300
@@ -0,0 +1,12 @@
+# PackageKit configuration for the pacman backend
+# See the pacman.conf(5) manpage for option and repository directives.
+
+[options]
+
+# Use default pacman configuration initially
+#
+Include = /etc/pacman.conf
+
+# Prevent PackageKit from removing itself
+#
+HoldPkg = packagekit
diff -Nru a/configure.ac b/configure.ac
--- a/configure.ac	2010-02-25 23:33:59.000000000 +1300
+++ b/configure.ac	2010-03-21 10:23:23.357630694 +1300
@@ -543,6 +543,7 @@
 AC_ARG_ENABLE(dummy, AS_HELP_STRING([--enable-dummy],[use the dummy backend]),enable_dummy=$enableval,enable_dummy=yes)
 AC_ARG_ENABLE(entropy, AS_HELP_STRING([--enable-entropy],[use the entropy backend]),enable_entropy=$enableval,enable_entropy=no)
 AC_ARG_ENABLE(opkg, AS_HELP_STRING([--enable-opkg],[use the OPKG backend]),enable_opkg=$enableval,enable_opkg=no)
+AC_ARG_ENABLE(pacman, AS_HELP_STRING([--enable-pacman],[use the PACMAN backend]),enable_pacman=$enableval,enable_pacman=no)
 AC_ARG_ENABLE(pisi, AS_HELP_STRING([--enable-pisi],[use the PiSi backend]),enable_pisi=$enableval,enable_pisi=no)
 AC_ARG_ENABLE(poldek, AS_HELP_STRING([--enable-poldek],[use the poldek backend]),enable_poldek=$enableval,enable_poldek=no)
 AC_ARG_ENABLE(portage, AS_HELP_STRING([--enable-portage],[use the portage backend]),enable_portage=$enableval,enable_portage=no)
@@ -563,6 +564,7 @@
 AM_CONDITIONAL(BACKEND_TYPE_DUMMY, [test x$enable_dummy = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_ENTROPY, [test x$enable_entropy = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_OPKG, [test x$enable_opkg = xyes])
+AM_CONDITIONAL(BACKEND_TYPE_PACMAN, [test x$enable_pacman = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_PISI, [test x$enable_pisi = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_POLDEK, [test x$enable_poldek = xyes])
 AM_CONDITIONAL(BACKEND_TYPE_PORTAGE, [test x$enable_portage = xyes])
@@ -651,6 +653,8 @@
 		with_default_backend=slapt
 	elif test -f /usr/bin/smart ; then
 		with_default_backend=smart
+	elif test -f /usr/lib/libpacman-glib.so ; then
+		with_default_backend=pacman
 	elif test -f /usr/bin/pisi ; then
 		with_default_backend=pisi
 	elif test -f /usr/bin/razor ; then
@@ -734,6 +738,12 @@
 			[AC_MSG_WARN([No alpm headers found - falling back to dummy backend])])
 fi
 
+if test x$enable_pacman = xyes; then
+	PKG_CHECK_MODULES(PACMAN, pacman-glib >= 3.3.0)
+	AC_SUBST(PACMAN_CFLAGS)
+	AC_SUBST(PACMAN_LIBS)
+fi
+
 if test x$enable_poldek = xyes; then
 	POLDEK_CFLAGS="-I/usr/include/poldek"
 	POLDEK_LIBS="-lpoclidek -lpoldek"
@@ -826,6 +836,7 @@
 backends/urpmi/helpers/urpmi_backend/Makefile
 backends/razor/Makefile
 backends/yum/Makefile
+backends/pacman/Makefile
 backends/pisi/Makefile
 backends/poldek/Makefile
 backends/portage/Makefile
@@ -892,6 +903,7 @@
         Entropy backend:           ${enable_entropy}
         OPKG backend:              ${enable_opkg}
         Razor backend:             ${enable_razor}
+        PACMAN backend:            ${enable_pacman}
         PiSi backend:              ${enable_pisi}
         poldek backend:            ${enable_poldek}
         Portage backend:           ${enable_portage}
